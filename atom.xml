<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>火之影</title>
  
  <subtitle>有思念你的人的地方就是你的归处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-23T09:22:43.409Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>火之影</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jwt的多种实现方式</title>
    <link href="http://yoursite.com/2019/11/03/jwt%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/03/jwt的多种实现方式/</id>
    <published>2019-11-03T14:12:02.000Z</published>
    <updated>2019-11-23T09:22:43.409Z</updated>
    
    <content type="html"><![CDATA[<p>本文将使用多种框架实现jwt认证并对每种方式进行讲解。<a id="more"></a></p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/Wanghongw/jwtDemos" target="_blank" rel="noopener"><a href="https://github.com/Wanghongw/jwtDemos" target="_blank" rel="noopener">https://github.com/Wanghongw/jwtDemos</a></a><br><code>实现的思路：</code><strong>用户先进行登陆认证，认证成功后生成token值（实际中可以将token保存在本地或者缓存中，本文为了方便直接打印在浏览器上，下一次请求直接复制粘贴到get请求的参数上或者Authorization头里），用户在访问<code>需要进行token校验的url时</code>带上之前生成的token的值让服务器进行校验，如果校验成功则返回正常的响应，否则返回错误信息。</strong></p><h3 id="基于django实现jwt"><a href="#基于django实现jwt" class="headerlink" title="基于django实现jwt"></a>基于django实现jwt</h3><h4 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jwtDjangoDemo</span><br><span class="line">├── api</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── db.sqlite3</span><br><span class="line">├── jwtDjangoDemo</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── middlewares</span><br><span class="line">│   └── jwt.py</span><br><span class="line">├── templates</span><br><span class="line">│   └── login.html</span><br><span class="line">└── utils</span><br><span class="line">    └── jwt_auth.py</span><br></pre></td></tr></table></figure><h5 id="脚本说明"><a href="#脚本说明" class="headerlink" title="脚本说明"></a>脚本说明</h5><ul><li><strong>utils中的jet_auth.py文件是生成与校验token的脚本</strong></li><li><strong>middlewares中的jwt.py文件是中间件进行校验的脚本</strong><ul><li>支持用户通过<code>url传参</code>或者使用<code>Authorization请求头</code>两种方式传递token</li><li>特别注意：这两个中间件同一时间只能使用一个，不可以同时注册</li></ul></li></ul><h4 id="过程讲解"><a href="#过程讲解" class="headerlink" title="过程讲解"></a>过程讲解</h4><p>1.用户先在浏览器中访问根目录：<code>127.0.0.1:8001</code>，根据设计会自动分发到登陆页面<br>2.在登陆页面输入用户名（whw）密码（666），点击提交<br>3.系统自动生成token值，如：<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"status"</span>: true, <span class="string">"token"</span>: <span class="string">"eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IndodyIsImV4cCI6MTU3NDQ5NTU5Nn0.DzS1oMBK967KS3ZUUvvF5RKlf3B9cOPL3eXLNpF5wMY"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>4.如果选择<code>url传参的方式传递token</code>，在浏览器的地址栏输入：<br>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8001/order/?token=eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IndodyIsImV4cCI6MTU3NDQ5NTU5Nn0.DzS1oMBK967KS3ZUUvvF5RKlf3B9cOPL3eXLNpF5wMY</span><br></pre></td></tr></table></figure></p><p>这样就可以正常访问订单列表了。<br>5.如果选择<code>Authorization请求头</code>的方法传递token，我这里使用<code>postman</code>工具模拟，注意请求头后面的value的值，形式是 <code>jwt token值</code>：<br>   <img src="http://whw.pythonav.cn/jwt2.png" alt="jwt2"></p><h5 id="关于生成加密token与token的解密的方法详见上一篇博客"><a href="#关于生成加密token与token的解密的方法详见上一篇博客" class="headerlink" title="关于生成加密token与token的解密的方法详见上一篇博客"></a>关于生成加密token与token的解密的方法详见上一篇博客</h5><h5 id="中间件中的校验"><a href="#中间件中的校验" class="headerlink" title="中间件中的校验"></a>中间件中的校验</h5><p>这里给出中间件的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> utils.jwt_auth <span class="keyword">import</span> parse_payload</span><br><span class="line"><span class="comment">#   白名单</span></span><br><span class="line">WHITE_LIST = [<span class="string">"/admin/.*"</span>,<span class="string">"/login/"</span>,<span class="string">"/"</span>]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JwtQueryParamMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户需要在url中通过参数进行传输token，例如：</span></span><br><span class="line"><span class="string">    127.0.0.1:8001/order?token=eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IndodyIsImV4cCI6MTU3NDQ5MTQ0MX0.K-k40u6XCvjDiYjhyfIqKsbrN4DCYkytqmdPHmBl9k0</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(request.path_info)</span><br><span class="line">        <span class="comment"># 白名单放行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> WHITE_LIST:</span><br><span class="line">            <span class="keyword">if</span> re.search(request.path_info,i):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 校验非登录页面的get请求</span></span><br><span class="line">        token = request.GET.get(<span class="string">'token'</span>)</span><br><span class="line">        result = parse_payload(token)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result[<span class="string">'status'</span>]:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(result,json_dumps_params=&#123;<span class="string">'ensure_ascii'</span>:<span class="literal">False</span>&#125;)</span><br><span class="line">        request.user_info = result[<span class="string">'data'</span>]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JwtAuthorizationMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户需要通过请求头的方式来进行传输token，例如（注意必须写成下面这种格式）：</span></span><br><span class="line"><span class="string">    Authorization:jwt eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzM1NTU1NzksInVzZXJuYW1lIjoid3VwZWlxaSIsInVzZXJfaWQiOjF9.xj-7qSts6Yg5Ui55-aUOHJS4KSaeLq5weXMui2IIEJU</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># 白名单放行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> WHITE_LIST:</span><br><span class="line">            <span class="keyword">if</span> re.search(request.path_info, i):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 非登录页面需要校验token</span></span><br><span class="line">        authorization = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>, <span class="string">''</span>)</span><br><span class="line">        auth = authorization.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'error'</span>: <span class="string">'未获取到Authorization请求头'</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> auth[<span class="number">0</span>].lower() != <span class="string">'jwt'</span>:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'error'</span>: <span class="string">'Authorization请求头中认证方式错误'</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> len(auth) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'error'</span>: <span class="string">"非法Authorization请求头"</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        <span class="keyword">elif</span> len(auth) &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'error'</span>: <span class="string">"非法Authorization请求头"</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        token = auth[<span class="number">1</span>]</span><br><span class="line">        result = parse_payload(token)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result[<span class="string">'status'</span>]:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(result)</span><br><span class="line">        request.user_info = result[<span class="string">'data'</span>]</span><br></pre></td></tr></table></figure><h3 id="基于DRF实现jwt"><a href="#基于DRF实现jwt" class="headerlink" title="基于DRF实现jwt"></a>基于DRF实现jwt</h3><p>此示例在drf的认证组件中对token进行校验，内部编写了两个认证组件来支持用户通过两种方式传递token。</p><ul><li><code>url</code>传参</li><li><code>Authorization</code>请求头<h4 id="过程简介"><a href="#过程简介" class="headerlink" title="过程简介"></a>过程简介</h4></li></ul><p>1.在浏览器中访问：<code>http://127.0.0.1:8002/api/v1/login/</code>进入登陆页面<br>2.输入用户名（whw）密码（666）<br>3.生成token的值：<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: true,</span><br><span class="line">    <span class="string">"token"</span>: <span class="string">"eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IndodyIsImV4cCI6MTU3NDQ5ODczNX0.fDs0s9AryVMKIXOKLidsE3MiC4d8Dybtm5384fou83c"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.访问order：<code>http://127.0.0.1:8002/api/v1/order/?token=eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IndodyIsImV4cCI6MTU3NDQ5ODczNX0.fDs0s9AryVMKIXOKLidsE3MiC4d8Dybtm5384fou83c</code><br>   此时可以看到正确的响应：<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"data"</span>: <span class="string">"订单列表"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.使用<code>Authorization请求头</code>的方式与上面django的方法一致，这里就不再多余说明了，结果如下：<br>   <img src="http://whw.pythonav.cn/jwt3.png" alt="jwt3"></p><h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h4><h5 id="认证类的写法"><a href="#认证类的写法" class="headerlink" title="认证类的写法"></a>认证类的写法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> exceptions</span><br><span class="line"><span class="keyword">from</span> utils.jwt_auth <span class="keyword">import</span> parse_payload</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JwtQueryParamAuthentication</span><span class="params">(BaseAuthentication)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户需要在url中通过参数进行传输token，例如：</span></span><br><span class="line"><span class="string">    http://127.0.0.1:8002/api/v1/order?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzM1NTU1NzksInVzZXJuYW1lIjoid3VwZWlxaSIsInVzZXJfaWQiOjF9.xj-7qSts6Yg5Ui55-aUOHJS4KSaeLq5weXMui2IIEJU</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        token = request.query_params.get(<span class="string">'token'</span>)</span><br><span class="line">        payload = parse_payload(token)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> payload[<span class="string">'status'</span>]:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(payload)</span><br><span class="line">        <span class="comment"># 如果想要request.user等于用户对象，此处可以根据payload去数据库中获取用户对象。</span></span><br><span class="line">        <span class="keyword">return</span> (payload, token)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JwtAuthorizationAuthentication</span><span class="params">(BaseAuthentication)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户需要通过请求头的方式来进行传输token，例如：</span></span><br><span class="line"><span class="string">    Authorization:jwt eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzM1NTU1NzksInVzZXJuYW1lIjoid3VwZWlxaSIsInVzZXJfaWQiOjF9.xj-7qSts6Yg5Ui55-aUOHJS4KSaeLq5weXMui2IIEJU</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># 非登录页面需要校验token</span></span><br><span class="line">        authorization = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>, <span class="string">''</span>)</span><br><span class="line">        auth = authorization.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(&#123;<span class="string">'error'</span>: <span class="string">'未获取到Authorization请求头'</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> auth[<span class="number">0</span>].lower() != <span class="string">'jwt'</span>:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(&#123;<span class="string">'error'</span>: <span class="string">'Authorization请求头中认证方式错误'</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> len(auth) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(&#123;<span class="string">'error'</span>: <span class="string">"非法Authorization请求头"</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        <span class="keyword">elif</span> len(auth) &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(&#123;<span class="string">'error'</span>: <span class="string">"非法Authorization请求头"</span>, <span class="string">'status'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        token = auth[<span class="number">1</span>]</span><br><span class="line">        result = parse_payload(token)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result[<span class="string">'status'</span>]:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(result)</span><br><span class="line">        <span class="comment"># 如果想要request.user等于用户对象，此处可以根据payload去数据库中获取用户对象。</span></span><br><span class="line">        <span class="keyword">return</span> (result, token)</span><br></pre></td></tr></table></figure><h5 id="视图类的写法"><a href="#视图类的写法" class="headerlink" title="视图类的写法"></a>视图类的写法</h5><p>直接注册认证类就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> utils.jwt_auth <span class="keyword">import</span> create_token</span><br><span class="line"><span class="keyword">from</span> extensions.auth <span class="keyword">import</span> JwtQueryParamAuthentication, JwtAuthorizationAuthentication</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">""" 用户登录 """</span></span><br><span class="line">        user = request.POST.get(<span class="string">'username'</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">'password'</span>)</span><br><span class="line">        <span class="comment"># 检测用户和密码是否正确，此处可以在数据进行校验。</span></span><br><span class="line">        <span class="keyword">if</span> user == <span class="string">'wupeiqi'</span> <span class="keyword">and</span> pwd == <span class="string">'123'</span>:</span><br><span class="line">            <span class="comment"># 用户名和密码正确，给用户生成token并返回</span></span><br><span class="line">            token = create_token(&#123;<span class="string">'username'</span>: <span class="string">'wupeiqi'</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'status'</span>: <span class="literal">True</span>, <span class="string">'token'</span>: token&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'status'</span>: <span class="literal">False</span>, <span class="string">'error'</span>: <span class="string">'用户名或密码错误'</span>&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="comment"># 通过url传递token</span></span><br><span class="line">    authentication_classes = [JwtQueryParamAuthentication, ]</span><br><span class="line">    <span class="comment"># 通过Authorization请求头传递token</span></span><br><span class="line">    <span class="comment"># authentication_classes = [JwtAuthorizationAuthentication, ]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        print(request.user, request.auth)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>: <span class="string">'订单列表'</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        print(request.user, request.auth)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>: <span class="string">'添加订单'</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        print(request.user, request.auth)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>: <span class="string">'修改订单'</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        print(request.user, request.auth)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>: <span class="string">'删除订单'</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="基于Flask实现jwt"><a href="#基于Flask实现jwt" class="headerlink" title="基于Flask实现jwt"></a>基于Flask实现jwt</h3><p>Flask的实现方式类似于Django中间件的实现方式，使用装饰器<code>before_request</code>，在路由分发之前处理一下请求，生成与校验token的代码与之前一样，Flask项目的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify, render_template, g</span><br><span class="line"><span class="keyword">from</span> utils.jwt_auth <span class="keyword">import</span> create_token, parse_payload</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 通过url传递token</span></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_query_params_auth</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.path == <span class="string">'/login/'</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    token = request.args.get(<span class="string">'token'</span>)</span><br><span class="line">    result = parse_payload(token)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result[<span class="string">'status'</span>]:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result)</span><br><span class="line">    g.user_info = result[<span class="string">'data'</span>]</span><br><span class="line"><span class="comment"># 通过Authorization请求头传递token</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@app.before_request</span></span><br><span class="line"><span class="string">def jwt_authorization_auth():</span></span><br><span class="line"><span class="string">    if request.path == '/login/':</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    authorization = request.headers.get('Authorization', '')</span></span><br><span class="line"><span class="string">    auth = authorization.split()</span></span><br><span class="line"><span class="string">    if not auth:</span></span><br><span class="line"><span class="string">        return jsonify(&#123;'error': '未获取到Authorization请求头', 'status': False&#125;)</span></span><br><span class="line"><span class="string">    if auth[0].lower() != 'jwt':</span></span><br><span class="line"><span class="string">        return jsonify(&#123;'error': 'Authorization请求头中认证方式错误', 'status': False&#125;)</span></span><br><span class="line"><span class="string">    if len(auth) == 1:</span></span><br><span class="line"><span class="string">        return jsonify(&#123;'error': "非法Authorization请求头", 'status': False&#125;)</span></span><br><span class="line"><span class="string">    elif len(auth) &gt; 2:</span></span><br><span class="line"><span class="string">        return jsonify(&#123;'error': "非法Authorization请求头", 'status': False&#125;)</span></span><br><span class="line"><span class="string">    token = auth[1]</span></span><br><span class="line"><span class="string">    result = parse_payload(token)</span></span><br><span class="line"><span class="string">    if not result['status']:</span></span><br><span class="line"><span class="string">        return jsonify(result)</span></span><br><span class="line"><span class="string">    g.user_info = result['data']</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">@app.route('/login/', methods=['GET','POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># GET请求返回登陆页面</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"login.html"</span>)</span><br><span class="line">    <span class="comment"># POST 方法 认证</span></span><br><span class="line">    user = request.form.get(<span class="string">'username'</span>)</span><br><span class="line">    pwd = request.form.get(<span class="string">'password'</span>)</span><br><span class="line">    <span class="comment"># 检测用户和密码是否正确，此处可以在数据进行校验。</span></span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">'whw'</span> <span class="keyword">and</span> pwd == <span class="string">'666'</span>:</span><br><span class="line">        <span class="comment"># 用户名和密码正确，给用户生成token并返回</span></span><br><span class="line">        token = create_token(&#123;<span class="string">'username'</span>: <span class="string">'wupeiqi'</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">'status'</span>: <span class="literal">True</span>, <span class="string">'token'</span>: token&#125;)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'status'</span>: <span class="literal">False</span>, <span class="string">'error'</span>: <span class="string">'用户名或密码错误'</span>&#125;)</span><br><span class="line"><span class="meta">@app.route('/order/', methods=['GET', "POST", "PUT", "DELETE"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">()</span>:</span></span><br><span class="line">    print(g.user_info)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"订单列表"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"订单信息"</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/wupeiqi/p/11854573.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/wupeiqi/p/11854573.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/p/11854573.html</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将使用多种框架实现jwt认证并对每种方式进行讲解。
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>从用户认证到jwt的说明</title>
    <link href="http://yoursite.com/2019/10/30/%E4%BB%8E%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%88%B0jwt%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2019/10/30/从用户认证到jwt的说明/</id>
    <published>2019-10-30T13:22:32.000Z</published>
    <updated>2019-11-23T09:38:17.249Z</updated>
    
    <content type="html"><![CDATA[<p>Json Web Token (JWT) 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。目前，jwt广泛应用在系统的用户认证方面，特别是现在前后端分离项目。<a id="more"></a></p><h3 id="session与token"><a href="#session与token" class="headerlink" title="session与token"></a>session与token</h3><p>关于用户认证肯定避不开session与token这两个技术点，因此在讨论jwt前我们很有必要谈一谈基于session与token的认证模式。</p><h4 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h4><p>我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用户向服务器发送用户名和密码。</span><br><span class="line"><span class="number">2</span>、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</span><br><span class="line"><span class="number">3</span>、服务器向用户返回一个 session_id，写入用户的 Cookie。</span><br><span class="line"><span class="number">4</span>、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</span><br><span class="line"><span class="number">5</span>、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure><p>但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.</p><h5 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h5><p><strong>Session</strong>: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，<code>服务端的开销</code>会明显增大。<br><strong>扩展性</strong>: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在<code>分布式</code>的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。<br><strong>CSRF</strong>: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到<code>跨站请求伪造</code>的攻击。</p><h4 id="基于token的校验机制"><a href="#基于token的校验机制" class="headerlink" title="基于token的校验机制"></a>基于token的校验机制</h4><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。<br>基于token的认证流程如下：<br><img src="http://whw.pythonav.cn/jwt1.png" alt="jwt1"><br>其实jwt也是基于这种流程实现的，只不过<code>jwt</code>与<code>传统的token</code>方式有一些区别。</p><h4 id="传统的token方式与jwt的差异"><a href="#传统的token方式与jwt的差异" class="headerlink" title="传统的token方式与jwt的差异"></a>传统的token方式与jwt的差异</h4><h5 id="传统的token方式"><a href="#传统的token方式" class="headerlink" title="传统的token方式"></a>传统的token方式</h5><p><strong>用户登录成功后，服务端生成一个随机token给用户，并且在服务端(数据库或缓存)中保存一份token，以后用户再来访问时需携带token，服务端接收到token之后，去数据库或缓存中进行校验token的是否超时、是否合法。</strong></p><h5 id="jwt方式"><a href="#jwt方式" class="headerlink" title="jwt方式"></a>jwt方式</h5><h5 id="用户登录成功后，服务端通过jwt生成一个随机token给用户（服务端无需保留token），以后用户再来访问时需携带token，服务端接收到token之后，通过jwt对token进行校验是否超时、是否合法。"><a href="#用户登录成功后，服务端通过jwt生成一个随机token给用户（服务端无需保留token），以后用户再来访问时需携带token，服务端接收到token之后，通过jwt对token进行校验是否超时、是否合法。" class="headerlink" title="用户登录成功后，服务端通过jwt生成一个随机token给用户（服务端无需保留token），以后用户再来访问时需携带token，服务端接收到token之后，通过jwt对token进行校验是否超时、是否合法。"></a><strong>用户登录成功后，服务端通过jwt生成一个随机token给用户（服务端无需保留token），以后用户再来访问时需携带token，服务端接收到token之后，通过jwt对token进行校验是否超时、是否合法。</strong></h5><h3 id="jwt的说明"><a href="#jwt的说明" class="headerlink" title="jwt的说明"></a>jwt的说明</h3><h4 id="jwt的原理"><a href="#jwt的原理" class="headerlink" title="jwt的原理"></a>jwt的原理</h4><p>jwt的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"姓名"</span>: <span class="string">"whw"</span>,</span><br><span class="line">  <span class="string">"角色"</span>: <span class="string">"火影"</span>,</span><br><span class="line">  <span class="string">"到期时间"</span>: <span class="string">"9999年09月09日09点09分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。<br>特别注意：<code>服务器不保存任何 session 数据</code>，也就是说，服务器变成无状态了，这样比较容易实现扩展。</p><h4 id="jwt的数据结构"><a href="#jwt的数据结构" class="headerlink" title="jwt的数据结构"></a>jwt的数据结构</h4><p>实际的jwt大概像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxxx.xx</span><br></pre></td></tr></table></figure><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。<br>jwt的三部分依次如下：</p><ul><li>头部（Header）</li><li>负载（Payload）</li><li>签名（Signature）<br>写成一行就是下面这样：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure></li></ul><h5 id="这三部分的生成规则如下："><a href="#这三部分的生成规则如下：" class="headerlink" title="这三部分的生成规则如下："></a>这三部分的生成规则如下：</h5><ul><li><p>第一段Header部分，固定包含算法和token类型，对此json进行base64url加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二段Payload部分，包含一些数据，对此json进行base64url加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"whw"</span>,</span><br><span class="line">  <span class="string">"iat"</span>: <span class="number">1516239022</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三段SIGNATURE部分，把前两段的base密文通过<code>.</code>拼接起来，然后对其进行<code>HS256</code>加密，再然后对<code>hs256</code>密文进行base64url加密，最终得到token的第三段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base64url(</span><br><span class="line">    HMACSHA256(</span><br><span class="line">      base64UrlEncode(header) + <span class="string">"."</span> + base64UrlEncode(payload),</span><br><span class="line">      your<span class="number">-256</span>-bit-secret (秘钥加盐)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p><code>最后将三段字符串通过</code>.<code>拼接起来就生成了jwt的token。</code><br><strong>注意</strong>：base64url加密是先做base64加密，然后再将 <code>-</code> 替代 <code>+</code> 及 <code>_</code> 替代 <code>/</code> 。</p><h3 id="代码实现token加密"><a href="#代码实现token加密" class="headerlink" title="代码实现token加密"></a>代码实现token加密</h3><ul><li><p>先安装jwt模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyjwt</span><br></pre></td></tr></table></figure></li><li><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> jwt <span class="keyword">import</span> exceptions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SALT = <span class="string">"huoyingwhw666"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 构造header</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"typ"</span>:<span class="string">"jwt"</span>,</span><br><span class="line">        <span class="string">"alg"</span>:<span class="string">"HS256"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 构造payload</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">"id"</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">"name"</span>:<span class="string">"whw"</span>,</span><br><span class="line">        <span class="string">"exp"</span>:datetime.datetime.now() + datetime.timedelta(hours=<span class="number">1</span>) <span class="comment"># 超时时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = jwt.encode(headers=headers,payload=payload,key=SALT,algorithm=<span class="string">"HS256"</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    token = create_token()</span><br><span class="line">    print(token)</span><br></pre></td></tr></table></figure></li><li><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwibmFtZSI6IndodyIsImV4cCI6MTU3NDUxNTk5MX0.AkUg9tnDhVX5iSUYXB2arGDlm9VOpKD1LAqpXwL3Ka8</span><br></pre></td></tr></table></figure></li></ul><h3 id="jwt校验token"><a href="#jwt校验token" class="headerlink" title="jwt校验token"></a>jwt校验token</h3><p>一般在认证成功后，把jwt生成的token返回给用户，以后用户再次访问时候需要携带token，此时jwt需要对token进行<code>超时</code>及<code>合法性</code>校验。</p><h4 id="校验过程"><a href="#校验过程" class="headerlink" title="校验过程"></a>校验过程</h4><p>获取token之后，会按照以下步骤进行校验：</p><ul><li>将token分割成 <code>header_segment</code>、<code>payload_segment</code>、<code>crypto_segment</code> 三部分</li><li>对第一部分<code>header_segment</code>进行base64url解密，得到<code>header</code></li><li>对第二部分<code>payload_segment</code>进行base64url解密，得到<code>payload</code></li><li>对第三部分<code>crypto_segment</code>进行base64url解密，得到<code>signature</code></li><li>对第三部分<code>signature</code>部分数据进行合法性校验<ul><li>拼接前两段密文，即：<code>signing_input</code></li><li>从第一段明文中获取加密算法，默认：<code>HS256</code></li><li>使用 算法+盐 对<code>signing_input</code> 进行加密，将得到的结果和<code>signature</code>密文进行比较。<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> jwt <span class="keyword">import</span> exceptions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SALT = <span class="string">"huoyingwhw666"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据token获取payload的值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_payload</span><span class="params">(token)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 从token中获取payload「不校验合法性」</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        unverified_payload = jwt.decode(token,None,False)</span></span><br><span class="line"><span class="string">        print(unverified_payload)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 从token中获取payload「校验合法性」</span></span><br><span class="line">        verified_payload = jwt.decode(token,SALT,<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"status"</span>:<span class="literal">True</span>,<span class="string">"msg"</span>:<span class="string">"认证成功"</span>,<span class="string">"payload"</span>:verified_payload&#125;</span><br><span class="line">    <span class="keyword">except</span> exceptions.ExpiredSignatureError:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"status"</span>:<span class="literal">False</span>,<span class="string">"msg"</span>:<span class="string">"token已失效"</span>&#125;</span><br><span class="line">    <span class="keyword">except</span> jwt.DecodeError:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"status"</span>: <span class="literal">False</span>, <span class="string">"msg"</span>: <span class="string">"token认证失败"</span>&#125;</span><br><span class="line">    <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"status"</span>: <span class="literal">False</span>, <span class="string">"msg"</span>: <span class="string">"非法的token"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 使用上一段代码生成的token值</span></span><br><span class="line">    token = <span class="string">"eyJ0eXAiOiJqd3QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwibmFtZSI6IndodyIsImV4cCI6MTU3NDUxNTk5MX0.AkUg9tnDhVX5iSUYXB2arGDlm9VOpKD1LAqpXwL3Ka8"</span></span><br><span class="line">    payload = get_payload(token)</span><br><span class="line">    print(payload)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'status'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: <span class="string">'认证成功'</span>, <span class="string">'payload'</span>: &#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'whw'</span>, <span class="string">'exp'</span>: <span class="number">1574515991</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="jwt的具体实现"><a href="#jwt的具体实现" class="headerlink" title="jwt的具体实现"></a>jwt的具体实现</h3><p>jwt实现的实例放在了我的github中：<a href="https://github.com/Wanghongw/jwtDemos" target="_blank" rel="noopener"><a href="https://github.com/Wanghongw/jwtDemos" target="_blank" rel="noopener">https://github.com/Wanghongw/jwtDemos</a></a><br>下一篇文章将详细讲解jwt实现的细节。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">单点登陆SSO介绍</a><br><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener"><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">https://www.jianshu.com/p/576dbf44b2ae</a></a><br><a href="https://www.cnblogs.com/wupeiqi/p/11854573.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/wupeiqi/p/11854573.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/p/11854573.html</a></a><br><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener"><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Json Web Token (JWT) 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。目前，jwt广泛应用在系统的用户认证方面，特别是现在前后端分离项目。
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Django中contenttypes组件的使用</title>
    <link href="http://yoursite.com/2019/09/22/Django%E4%B8%ADcontenttypes%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/22/Django中contenttypes组件的使用/</id>
    <published>2019-09-22T09:21:23.000Z</published>
    <updated>2019-09-22T13:53:04.184Z</updated>
    
    <content type="html"><![CDATA[<p>contenttypes是Django内置的一个非常有用的组件，它对当前项目中所有基于Django驱动的model提供了更高层次的接口，简单点说，它可以追踪项目中所有的应用与model的对应关系并将这些关系记录在ContentType表中，每当我们创建了新的model并执行数据库迁移指令后，ContentType表中就会自动新增一条不同应用和这个应用中的model之间对应关系的记录；更重要的是，我们不仅可以使用contenttypes提供的<code>GenericForeignKey类</code>与<code>GenericReleation类</code>去避免因大量复杂的ORM查询导致的程序效率降低，而且在实际项目中使用contenttypes还会优化项目数据库表结构的设计，避免数据库中产生许多无用的数据。<br>本文用一个简单的业务为例详细为大家介绍一下使用contenttypes组件有何优点、组件的具体用法及其使用场景等等。<a id="more"></a></p><h3 id="Django中的contenttypes组件"><a href="#Django中的contenttypes组件" class="headerlink" title="Django中的contenttypes组件"></a><code>Django中的contenttypes组件</code></h3><p>假如说，公司A的主要业务是培训青少年人工智能与机器人技术，主要分类是<code>基础课程</code>与<code>高级课程</code>，而这两个大的分类中又有其他具体的课程。每个课程根据培训周期的不同培训费用的计算方式也不一样。也许没有做过相关业务的同学还没有get到相关的点，这里我先粗略的画一下表结构，后面再详细阐述。</p><h4 id="初版表结构设计"><a href="#初版表结构设计" class="headerlink" title="初版表结构设计"></a><code>初版表结构设计</code></h4><p>如果不用contenttypes，大致的表结构会这么设计：<br><img src="http://whw.pythonav.cn/contenttypes1.png" alt="image-20190922200038809"><br>由上图我们可以看到基础课程与高级课程下有多个不同的子课程。<br>接下来看一下<code>价格策略</code>这张表，每个小课程（比如Python初级与Python高级）由于培训周期的不同价格是不一样的<code>（这里只是模拟，请勿对号入座）</code>，并且PricePolicy表中<code>journeycourse_id</code>与<code>seniorcourse_id</code>是与两个课程表建立外键的字段——此时聪明的你立刻就发现问题了：初级课程的周期最多周期只有21天，而高级课程的培训周期是按月来计算的！如果这样会导致数据库中产生许多无用的空数据！<br>上面这个问题这是一个很典型的<code>一张表与多张表动态的创建ForeignKey关系</code>的问题，而要解决上面产生无用数据的问题<code>可以选择使用Django中的contenttypes</code>。</p><h4 id="使用contenttypes的表结构"><a href="#使用contenttypes的表结构" class="headerlink" title="使用contenttypes的表结构"></a><code>使用contenttypes的表结构</code></h4><p><img src="http://whw.pythonav.cn/contenttypes2.png" alt="image-20190922202135890"><br><strong>详细说明如下：</strong></p><ol><li>新增了一个ContentType表（settings中默认注册了contenttypes组件，Django启动时会自动生成），这个表中存放了model的名称；</li><li>价格策略表中的content_type_id字段是<code>PricePolicy</code>表与<code>ContentType</code>表之间外键关联的字段；</li><li>价格策略表中的object_id字段对应的是<code>基础课程</code>或者<code>高级课程</code>中具体的子类课程的id；</li><li>在价格策略表中，我们可以根据大课程的分类<code>content_type_id</code>、子课程的id<code>object_id</code>以及培训的周期<code>period</code>确定一条唯一的记录！</li><li>特别注意<code>object_id</code>只是一个普通的字段，它并没有与任何表建立外键关联！<br>这样设计的话就不会出现上面那种空的无效数据了！<h4 id="contenttypes的具体实现"><a href="#contenttypes的具体实现" class="headerlink" title="contenttypes的具体实现"></a><code>contenttypes的具体实现</code></h4>老规矩，先上代码，后面给出具体的说明！<br>项目应用中的models.py文件如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericForeignKey,GenericRelation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JuniorCourse</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""初级课程"""</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>,verbose_name=<span class="string">'初级课程名称'</span>)</span><br><span class="line">    course_img = models.CharField(max_length=<span class="number">255</span>, verbose_name=<span class="string">"课程缩略图"</span>)</span><br><span class="line">    brief = models.TextField(verbose_name=<span class="string">"初级课程简介"</span>, )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不会在数据库中生成列，只是帮我们添加与查询数据用的</span></span><br><span class="line">    <span class="comment"># 建立GenericRelation的字段如果被删除的话，PricePolicy中对应的记录也会被删掉！</span></span><br><span class="line">    policy_lst = GenericRelation(<span class="string">'PricePolicy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeniorCourse</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""高级课程"""</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>, verbose_name=<span class="string">'进阶级课程名称'</span>)</span><br><span class="line">    course_img = models.CharField(max_length=<span class="number">255</span>, verbose_name=<span class="string">"课程缩略图"</span>)</span><br><span class="line">    brief = models.TextField(verbose_name=<span class="string">"进阶级课程简介"</span>, )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不会在数据库中生成列，只是帮我们添加与查询数据用的</span></span><br><span class="line">    <span class="comment"># 建立GenericRelation的字段如果被删除的话，PricePolicy中对应的记录也会被删掉！</span></span><br><span class="line">    policy_lst = GenericRelation(<span class="string">'PricePolicy'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PricePolicy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""价格策略——课程有效期与价格表"""</span></span><br><span class="line">    <span class="comment"># 与ContentType表做关联 —— 找到大的分类</span></span><br><span class="line">    content_type = models.ForeignKey(to=ContentType,on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># 对应"大分类中的课程的id"，用正整数表示 —— 名字必须叫object_id</span></span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不会在数据库中生成列，只是帮我们添加与查询查询数据用的</span></span><br><span class="line">    content_object = GenericForeignKey(<span class="string">'content_type'</span>,<span class="string">'object_id'</span>)</span><br><span class="line"></span><br><span class="line">    valid_period_choices = (</span><br><span class="line">        (<span class="number">1</span>,<span class="string">'1天'</span>),</span><br><span class="line">        (<span class="number">3</span>,<span class="string">'3天'</span>),</span><br><span class="line">        (<span class="number">7</span>,<span class="string">'1周'</span>),</span><br><span class="line">        (<span class="number">14</span>,<span class="string">'2周'</span>),</span><br><span class="line">        (<span class="number">21</span>,<span class="string">'3周'</span>),</span><br><span class="line">        (<span class="number">30</span>,<span class="string">'1个月'</span>),</span><br><span class="line">        (<span class="number">60</span>,<span class="string">'2个月'</span>),</span><br><span class="line">        (<span class="number">90</span>,<span class="string">'3个月'</span>),</span><br><span class="line">    )</span><br><span class="line">    valid_period = models.SmallIntegerField(choices=valid_period_choices,verbose_name=<span class="string">'课程周期'</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><p><strong>详细说明如下：</strong><br><strong>1、</strong>大家首先要注意一点：由于项目的settings.py文件中默认注册了<code>django.contrib.contenttypes</code>这个组件，所以我们在<code>执行数据库迁移指令</code>的时候，Django会自动为我们创建一张铭文<code>django_content_type</code>的表，存放项目应用与应用里面model对应关系：<br><img src="http://whw.pythonav.cn/contenttypes3.png" alt="image-20190922203753923"><br>可以看到，最下面那三条记录就是我上面的代码执行<code>数据库迁移指令</code>后生成的——我的应用名叫testapp。<br><strong>2、</strong>引用这张<code>django_content_type</code>表的方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br></pre></td></tr></table></figure><p>注意不要改这张表！我们从里面查数据就好了——基本上都是查model。<br><strong>3、</strong>我们来看一下<code>PricePolicy</code>这个类：首先它与ContentType表建立了外键关联，<code>content_object</code>这个属性是<code>GenericForeignKey</code>类实例化的对象，参数是上面的<code>content_type</code>与<code>object_id</code>属性——这步操作不会在数据库中创建新的列，是为了方便我们后续添加与查询数据用的。我们在知道了价格策略的条件下可以根据<code>GenericForeignKey</code>对应的属性查到具体的课程。<br><strong>4、</strong><code>GenericRelation</code>写在了具体课程的类下面，我们可以它实例化的属性，拿课程对象去查询这个课程对应的价格策略都有哪些——但是要注意一点：GenericRelation对应字段的对象如果被删除的话，PricePolicy中对应的记录也会被删掉！也就是说，根据上面建立的model关系，如果我删除了一条seniorcourse中的记录，那与这条记录对应的pricepolicy中的记录也会被删除！</p><h4 id="视图函数中的增删改查"><a href="#视图函数中的增删改查" class="headerlink" title="视图函数中的增删改查"></a><code>视图函数中的增删改查</code></h4><p>上面介绍了在<code>models.py</code>中如何用contenttypes，接下来我们来看看如何在视图函数中使用它。</p><h5 id="向价格策略表中添加数据"><a href="#向价格策略表中添加数据" class="headerlink" title="向价格策略表中添加数据"></a><code>向价格策略表中添加数据</code></h5><p>由于上面的<code>models.py</code>文件中我们在<code>PricePolicy</code>类中定义了<code>content_object</code>这个<code>GenericForeignkey</code>类的实例化对象，在创建数据的时候直接指定<code>content_object</code>就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与seniorcourse表的关系</span></span><br><span class="line">models.PricePolicy.objects.create(</span><br><span class="line">    valid_period=<span class="number">7</span>,</span><br><span class="line">    price=<span class="number">123.45</span>,</span><br><span class="line">    <span class="comment"># 直接根据SeniorCourse对象添加</span></span><br><span class="line">    content_object = models.SeniorCourse.objects.get(pk=<span class="number">2</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 与juniorcourse表的关系</span></span><br><span class="line">models.PricePolicy.objects.create(</span><br><span class="line">    valid_period=<span class="number">3</span>,</span><br><span class="line">    price=<span class="number">35.66</span>,</span><br><span class="line">    <span class="comment"># # 直接根据JuniorCourse对象添加</span></span><br><span class="line">    content_object = models.JuniorCourse.objects.get(pk=<span class="number">1</span>),</span><br></pre></td></tr></table></figure><p>其他两张课程表直接添加数据就好了，没有任何的约束。</p><h5 id="根据某个价格策略对象去找与它对应的表的数据"><a href="#根据某个价格策略对象去找与它对应的表的数据" class="headerlink" title="根据某个价格策略对象去找与它对应的表的数据"></a><code>根据某个价格策略对象去找与它对应的表的数据</code></h5><p>这里其实还是利用了<code>GenericForeignKey</code>，自动<code>跨表查询</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在ContentType表中找到具体的表</span></span><br><span class="line">contenttype_obj = ContentType.objects.get(model=<span class="string">'seniorcourse'</span>)</span><br><span class="line"><span class="comment"># 找到价格策略对象</span></span><br><span class="line"><span class="comment"># 注意get是查询唯一对象的方法，所以给出的条件必须保证只查到一个对象！</span></span><br><span class="line">obj=models.PricePolicy.objects.get(content_type=contenttype_obj,object_id=<span class="number">1</span>,valid_period=)</span><br><span class="line">    <span class="comment">### 直接“跨表查询”就好了</span></span><br><span class="line">    print(obj.content_object.name)</span><br></pre></td></tr></table></figure><h5 id="找到某个课程相关的所有价格策略"><a href="#找到某个课程相关的所有价格策略" class="headerlink" title="找到某个课程相关的所有价格策略***"></a><code>找到某个课程相关的所有价格策略***</code></h5><p>这个在实际中用的还是很多的！这里用到了<code>GenericRelation</code>，也就是上面<code>models.py</code>文件中定义在高级课程与初级课程类中的那两个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = models.SeniorCourse.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 注意这里必须用all()方法</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> obj.policy_lst.all():</span><br><span class="line">        print(i.pk,i.valid_period,i.price)</span><br></pre></td></tr></table></figure><h5 id="课程中如果用了GenericRelation类实例化出来的对象作为属性的话，删除课程中的数据时，价格策略中与之相关的数据也会一起被删除！"><a href="#课程中如果用了GenericRelation类实例化出来的对象作为属性的话，删除课程中的数据时，价格策略中与之相关的数据也会一起被删除！" class="headerlink" title="课程中如果用了GenericRelation类实例化出来的对象作为属性的话，删除课程中的数据时，价格策略中与之相关的数据也会一起被删除！"></a><code>课程中如果用了GenericRelation类实例化出来的对象作为属性的话，删除课程中的数据时，价格策略中与之相关的数据也会一起被删除！</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除了SeniorCourse中的一个课程后，PricePublic中与之相关的数据都删除了！！！</span></span><br><span class="line">models.SeniorCourse.objects.get(pk=<span class="number">1</span>).delete()</span><br></pre></td></tr></table></figure><h3 id="contenttypes使用小结"><a href="#contenttypes使用小结" class="headerlink" title="contenttypes使用小结"></a><code>contenttypes使用小结</code></h3><p>根据上面的介绍，其实contenttypes的使用大致分为这几步：</p><ol><li>创建ContentType表（Django的settings中默认注册了contenttypes应用，启动时会自动生成）；</li><li>价格策略表与ContentType表建立外键关联关系；</li><li>定义<code>GenericForeignKey</code>属性，根据价格策略表中的记录去查询具体课程的信息或者根据课程对象创建价格策略的记录；</li><li>定义<code>GenericRelation</code>的属性，根据具体的课程对象在价格策略表中查找与这个课程相关的所有的价格策略；</li><li>定义了<code>GenericRelation</code>的属性的话需要注意：删除课程中的一条记录价格策略表中与这个课程相关的所有记录也都会被删除掉！<h3 id="contenttypes的使用场景"><a href="#contenttypes的使用场景" class="headerlink" title="contenttypes的使用场景"></a><code>contenttypes的使用场景</code></h3>在实际中，contenttypes绝大多数都用在<code>一张表与N张表动态的创建ForeignKey关系</code>的场景下。<br>其实实际中contenttypes的使用场景还是很多的，比如<code>评论功能</code>：如果一个网站的文章、视频、图片等都需要加评论的话，我们可以把评论这张表与文章、图片、视频都建立向上面那样的<code>外键关联</code>；再拿上面的例子来说，我们可以为不同分类下的没门课程加入<code>优惠券</code>，优惠券这张表跟<code>价格策略表</code>性质一样，也需要与那两张课程表建立外键关系，此时使用contenttypes会十分高效！<h3 id="更多参考文章"><a href="#更多参考文章" class="headerlink" title="更多参考文章"></a><code>更多参考文章</code></h3><a href="https://docs.djangoproject.com/en/2.1/ref/contrib/contenttypes/" target="_blank" rel="noopener">官方文档</a><br><a href="https://blog.csdn.net/laughing2333/article/details/53014267" target="_blank" rel="noopener">https://blog.csdn.net/laughing2333/article/details/53014267</a><br><a href="https://blog.csdn.net/weixin_42134789/article/details/80690182" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42134789/article/details/80690182</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;contenttypes是Django内置的一个非常有用的组件，它对当前项目中所有基于Django驱动的model提供了更高层次的接口，简单点说，它可以追踪项目中所有的应用与model的对应关系并将这些关系记录在ContentType表中，每当我们创建了新的model并执行数据库迁移指令后，ContentType表中就会自动新增一条不同应用和这个应用中的model之间对应关系的记录；更重要的是，我们不仅可以使用contenttypes提供的&lt;code&gt;GenericForeignKey类&lt;/code&gt;与&lt;code&gt;GenericReleation类&lt;/code&gt;去避免因大量复杂的ORM查询导致的程序效率降低，而且在实际项目中使用contenttypes还会优化项目数据库表结构的设计，避免数据库中产生许多无用的数据。&lt;br&gt;本文用一个简单的业务为例详细为大家介绍一下使用contenttypes组件有何优点、组件的具体用法及其使用场景等等。
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="contenttypes组件" scheme="http://yoursite.com/tags/contenttypes%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7系统中部署Django项目</title>
    <link href="http://yoursite.com/2019/09/21/%E5%9C%A8CentOS7%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/09/21/在CentOS7系统中部署Django项目/</id>
    <published>2019-09-21T04:23:34.000Z</published>
    <updated>2019-09-21T08:54:41.559Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名后端开发的程序员不仅要会写业务代码、解决各种BUG、优化项目性能，也应该知道如何将自己写好的项目部署到服务器中让别人去访问。<br>本文详细讲解了用一台安装了CentOS7.5系统的裸奔Linux机器（虚拟机）从零开始部署django项目的过程。<a id="more"></a></p><h2 id="安装必要的工具"><a href="#安装必要的工具" class="headerlink" title="安装必要的工具"></a>安装必要的工具</h2><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><p>至于什么是yum源大家请自行百度，本人用的是<a href="https://yq.aliyun.com/zt/59505" target="_blank" rel="noopener">阿里云的yum源</a>，因此需要在裸机上配置一下：</p><h4 id="进入yum源的目录"><a href="#进入yum源的目录" class="headerlink" title="进入yum源的目录"></a>进入yum源的目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure><h4 id="查看yum源文件"><a href="#查看yum源文件" class="headerlink" title="查看yum源文件"></a>查看yum源文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="http://whw.pythonav.cn/%E9%83%A8%E7%BD%B21.png" alt="img11"> </p><h4 id="配置阿里云yum源"><a href="#配置阿里云yum源" class="headerlink" title="配置阿里云yum源"></a>配置阿里云yum源</h4><p><strong>1.好习惯，备份yum源</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir repo_bak</span><br><span class="line">mv *.repo repo_bak/</span><br></pre></td></tr></table></figure><p><strong>2.下载阿里云repo文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.aliyun.com/repo/Centos<span class="number">-7.</span>repo</span><br></pre></td></tr></table></figure><p><strong>3.清空yum缓存并且生成新的yum缓存</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><strong>4.安装软件扩展源</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><h3 id="安装pthon3"><a href="#安装pthon3" class="headerlink" title="安装pthon3"></a>安装pthon3</h3><p>推荐利用编译的方式安装Python3。</p><h4 id="安装依赖环境——非常重要"><a href="#安装依赖环境——非常重要" class="headerlink" title="安装依赖环境——非常重要"></a>安装依赖环境——非常重要</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel -y</span><br></pre></td></tr></table></figure><h4 id="下载解压源码包"><a href="#下载解压源码包" class="headerlink" title="下载解压源码包"></a>下载解压源码包</h4><p>需要注意的是，Linux系统的第三方软件都约定俗成的安装在/opt目录下~因此我们需要把这个包下载到/opt目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://www.python.org/ftp/python/<span class="number">3.6</span><span class="number">.5</span>/Python<span class="number">-3.6</span><span class="number">.5</span>.tgz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python<span class="number">-3.6</span><span class="number">.5</span>.tgz</span><br></pre></td></tr></table></figure><h4 id="开始编译安装"><a href="#开始编译安装" class="headerlink" title="开始编译安装"></a>开始编译安装</h4><p><strong>configure</strong><br>进入解压出出来的Python-3.6.5目录，里面有一个绿色的可执行文件configure~<br>这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/py365</span><br></pre></td></tr></table></figure><p>上面的意思是将该软件安装在 /opt/py365 下面，执行文件就会安装在 /opt/py365/bin （而不是默认的 /usr/local/bin)，资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。<br>同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。<br><strong>——我这里没有加后面的参数，直接执行 ./configure，默认安装在了/usr/local/bin中~</strong><br><strong>make</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。</span><br><span class="line">如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</span><br><span class="line">make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。</span><br><span class="line">make 是 [Linux](http://www.icultivator.com/tag/linux) 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 [gcc](http://www.icultivator.com/tag/gcc) 、ld 以及运行某些需要的程序进行编译的程序。一般情况下，他所使用的 Makefile 控制代码，由 configure 这个设置脚本根据给定的参数和系统环境生成。</span><br></pre></td></tr></table></figure><p><strong>make install</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这条命令来进行安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）</span><br></pre></td></tr></table></figure><h3 id="安装虚拟环境包virtualenv及管理工具virtualenvwrapper"><a href="#安装虚拟环境包virtualenv及管理工具virtualenvwrapper" class="headerlink" title="安装虚拟环境包virtualenv及管理工具virtualenvwrapper"></a>安装虚拟环境包virtualenv及管理工具virtualenvwrapper</h3><p>我自己之前总结过两篇相关的博客（原创哦）：<br><a href="https://www.cnblogs.com/paulwhw/articles/11103162.html" target="_blank" rel="noopener">linux下虚拟环境模块virtualenv及管理工具virtualenvwrapper的使用</a><br><a href="https://www.cnblogs.com/paulwhw/articles/11105376.html" target="_blank" rel="noopener">windows与mac下virtualenv与Pycharm的结合使用</a></p><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>nginx的安装也推荐编译安装！<br>由于本文用的是一个裸机，如果大家之前用yum安装了nginx，请卸载yum安装的nginx！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove nginx -y</span><br></pre></td></tr></table></figure><h4 id="解决软件包依赖——特别重要"><a href="#解决软件包依赖——特别重要" class="headerlink" title="解决软件包依赖——特别重要"></a>解决软件包依赖——特别重要</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</span><br></pre></td></tr></table></figure><h4 id="下载nginx的源码包并解压"><a href="#下载nginx的源码包并解压" class="headerlink" title="下载nginx的源码包并解压"></a>下载nginx的源码包并解压</h4><p>我这里用的是淘宝的<a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a>——在原始nginx上扩展了许多功能<del>很强大</del><br>需要注意的是，Linux系统的第三方软件都约定俗成的安装在/opt目录下~因此我们需要把这个包下载到/opt目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget http://tengine.taobao.org/download/tengine<span class="number">-2.3</span><span class="number">.1</span>.tar.gz</span><br></pre></td></tr></table></figure><p>解压tengine包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf tengine<span class="number">-2.3</span><span class="number">.1</span>.tar.gz</span><br></pre></td></tr></table></figure><h4 id="安装tengine"><a href="#安装tengine" class="headerlink" title="安装tengine"></a>安装tengine</h4><p>进入源码目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd tengine<span class="number">-2.3</span><span class="number">.1</span>/</span><br></pre></td></tr></table></figure><p>里面有一个绿色的可执行文件configure<br>这里我们指定将tengine安装在/opt/tngx231这个目录下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/tngx231/</span><br></pre></td></tr></table></figure><p>然后进行编译安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>结束后我们可以看到新生成了一个/opt/tngx321目录<br>安装好的nginx放在了 /opt/tngx231/sbin/ 这个目录下了~</p><h4 id="修改环境变量让nginx命令生效"><a href="#修改环境变量让nginx命令生效" class="headerlink" title="修改环境变量让nginx命令生效"></a>修改环境变量让nginx命令生效</h4><p>安装完成后需要每次用/opt/tngx231/sbin/ 这个目录加上nginx才能操作，很烦躁，我们可以通过修改环境变量，以后只需要执行nginx就可以启用nginx的操作了~<br><strong>&lt;1&gt;首先确认下当前的环境变量有哪些目录：</strong>         </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH   </span><br><span class="line"><span class="comment">#/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span></span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt; 编辑/etc/profile文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><strong>&lt;3&gt;在文件的最后一行输入 ：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="string">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/opt/tngx231/sbin"</span></span><br></pre></td></tr></table></figure><p>并 :wq 保存退出~~<br><strong>&lt;4&gt;最后一定要记得source一下 /etc/profile 文件！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="nginx的启停命令"><a href="#nginx的启停命令" class="headerlink" title="nginx的启停命令"></a>nginx的启停命令</h4><p>在没有修改环境变量之前，我们需要进入nginx的安装目录（本文是在 /opt/tngx231/sbin/ ）这样执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./nginx <span class="comment">#启动</span></span><br><span class="line">./nginx -s stop <span class="comment">#关闭</span></span><br><span class="line">./nginx -s reload <span class="comment">#重新加载</span></span><br></pre></td></tr></table></figure><p>修改了环境变量后可以直接这样执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx <span class="comment">#启动</span></span><br><span class="line">nginx -t <span class="comment">#查看nginx状态</span></span><br><span class="line">nginx -s stop <span class="comment">#关闭</span></span><br><span class="line">nginx -s reload <span class="comment">#重新加载</span></span><br></pre></td></tr></table></figure><p>测试nginx的服务<br>安装完成后别忘了检测一下nginx的服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp |grep <span class="number">80</span></span><br><span class="line">curl -I <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="http://whw.pythonav.cn/%E9%83%A8%E7%BD%B22.png" alt="img"><br><strong>如果访问不了，检查selinux，iptables</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关防火墙</span></span><br><span class="line">systemctl disable firewalled</span><br><span class="line">setenforce <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="项目部署过程"><a href="#项目部署过程" class="headerlink" title="项目部署过程"></a>项目部署过程</h2><h3 id="创建虚拟环境并在虚拟环境中安装必要的包"><a href="#创建虚拟环境并在虚拟环境中安装必要的包" class="headerlink" title="创建虚拟环境并在虚拟环境中安装必要的包"></a>创建虚拟环境并在虚拟环境中安装必要的包</h3><p>利用virtualenvwrapper工具创建虚拟环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv whw_dj1</span><br></pre></td></tr></table></figure><p>创建完虚拟环境后直接会进入这个虚拟环境。<br>在这个环境中安装项目需要的包，安装过程略（直接用pip安装即可），结果如下：<br><img src="http://whw.pythonav.cn/%E9%83%A8%E7%BD%B23.png" alt="img"><br>这里需要记录一下uwsgi的执行路径以及虚拟环境的目录，后面要用：<br><strong>uwsgi的执行路径</strong><br><strong>特别注意：如果在虚拟环境中运行的话，后面执行uwsgi命令需要用绝对路径的时候一定是虚拟环境中的这个绝对路径！</strong><br><strong>(补充说明一点：如果虚拟环境中没有安装uwsgi模块的话会显示外部环境中的位置，因此一定要记得在虚拟环境中安装uwsgi模块!)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(whw_di1) [root@bogon opt]<span class="comment"># which uwsgi</span></span><br><span class="line">/root/Envs/whw_di1/bin/uwsgi</span><br></pre></td></tr></table></figure><p><strong>虚拟环境的目录</strong><br><strong>特别注意：如果在虚拟环境中运行的话，后面uwsgi的配置文件一定要写当前虚拟环境下的uwsgi的绝对路径！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(whw_di1) [root@bogon opt]<span class="comment"># cdvirtualenv </span></span><br><span class="line">(whw_di1) [root@bogon whw_di1]<span class="comment"># pwd</span></span><br><span class="line">/root/Envs/whw_di1</span><br></pre></td></tr></table></figure><h3 id="项目文件settings与静态文件相关的配置"><a href="#项目文件settings与静态文件相关的配置" class="headerlink" title="项目文件settings与静态文件相关的配置"></a>项目文件settings与静态文件相关的配置</h3><p>将项目传到服务器的/opt目录~进入项目的二级目录，配置一下里面的settings文件，这里只写与部署相关的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线上部署一定要记得把DEBUG改成False</span></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 94这个ip是我的云服务器的Ip，一般情况下是这样配置</span></span><br><span class="line"><span class="comment"># ALLOWED_HOSTS = ['localhost','94.191.41.167','0.0.0.0:8000','127.0.0.1' ]</span></span><br><span class="line"><span class="comment"># 自己测试的话直接allow所有的ip就好了</span></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">'*'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sqllit数据库的配置</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">     <span class="string">'default'</span>: &#123;</span><br><span class="line">         <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">         <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态文件配置</span></span><br><span class="line"><span class="comment"># 第一个参数是将静态文件copy到服务器的目录的位置</span></span><br><span class="line">STATIC_ROOT=<span class="string">'/opt/whw_static/'</span></span><br><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR,<span class="string">'staticfiles'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## mysql的配置——本文用的是sqllit，因此这个配置注释掉</span></span><br><span class="line"><span class="comment">#DATABASES = &#123;</span></span><br><span class="line"><span class="comment">#    'default': &#123;</span></span><br><span class="line"><span class="comment">#        'ENGINE': 'django.db.backends.mysql',#引擎，选mysql</span></span><br><span class="line"><span class="comment">#        'NAME':'whw1',#要连接的数据库，连接前需要创建好</span></span><br><span class="line"><span class="comment">#        'USER':'root',#连接数据库的用户名</span></span><br><span class="line"><span class="comment">#        'PASSWORD':'123',#连接数据库的密码</span></span><br><span class="line"><span class="comment">#        'HOST':'127.0.0.1',#连接主机，默认本本机</span></span><br><span class="line"><span class="comment">#        'PORT':3306,#端口 默认3306</span></span><br><span class="line"><span class="comment">#        #Django中设置数据库的严格模式</span></span><br><span class="line"><span class="comment">#       'OPTIONS':&#123;</span></span><br><span class="line"><span class="comment">#           'init_command':"set sql_mode='STRICT_TRANS_TABLES' ",</span></span><br><span class="line"><span class="comment">#           &#125;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br></pre></td></tr></table></figure><p>由于uwsgi不能处理项目的静态文件，我们需要用nginx来处理，因此需要<strong>将项目的静态文件copy到STATIC_ROOT参数对应的位置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3  /opt/whw/manage.py  collectstatic</span><br></pre></td></tr></table></figure><p>whw是我的项目的第一层目录，就是我的项目的名字。</p><h3 id="uwsgi的配置"><a href="#uwsgi的配置" class="headerlink" title="uwsgi的配置"></a>uwsgi的配置</h3><p>提醒一点：需要提前在虚拟环境中安装好uwsgi包~~</p><h4 id="uwsgi-ini文件的配置"><a href="#uwsgi-ini文件的配置" class="headerlink" title="uwsgi.ini文件的配置"></a>uwsgi.ini文件的配置</h4><p>配置uwsgi之前需要新建一个uwsgi.ini文件。<br>由于每个项目对应一个uwsgi.ini文件，这里建议大家将这个文件创建在自己项目的第一层目录中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/whw/</span><br><span class="line">touch uwsgi.ini</span><br></pre></td></tr></table></figure><p>然后编辑这个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim uwsgi.ini</span><br></pre></td></tr></table></figure><p>文件中的配置如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"><span class="comment"># Django-related settings</span></span><br><span class="line"><span class="comment"># the base directory (full path)</span></span><br><span class="line"><span class="comment">#项目的绝对路径,定位到项目的第一层</span></span><br><span class="line">chdir = /opt/whw</span><br><span class="line"><span class="comment"># Django's wsgi file</span></span><br><span class="line"><span class="comment"># 找到项目第二层的wsgi文件</span></span><br><span class="line">module = whw.wsgi</span><br><span class="line"><span class="comment"># the virtualenv (full path)</span></span><br><span class="line"><span class="comment"># 找到虚拟环境的绝对路径~注意最后不要加/!!!</span></span><br><span class="line">home = /root/Envs/whw_di1</span><br><span class="line"><span class="comment"># process-related settings</span></span><br><span class="line"><span class="comment"># master</span></span><br><span class="line"><span class="comment"># 主进程</span></span><br><span class="line">master = true</span><br><span class="line"><span class="comment"># maximum number of worker processes</span></span><br><span class="line"><span class="comment"># 开启uwsgi的多进程数,根据cpu核数来定义</span></span><br><span class="line">processes = <span class="number">16</span></span><br><span class="line"><span class="comment"># the socket (use the full path to be safe</span></span><br><span class="line"><span class="comment"># 基于socket链接运行项目,只有与nginx结合的时候,才使用socket形式</span></span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 当你没用nginx,调试项目的时候,使用http形式 </span></span><br><span class="line"><span class="comment">#http =  0.0.0.0:8000</span></span><br><span class="line"><span class="comment"># ... with appropriate permissions - may be needed</span></span><br><span class="line"><span class="comment"># chmod-socket    = 664</span></span><br><span class="line"><span class="comment"># clear environment on exit</span></span><br><span class="line">vacuum = true</span><br><span class="line"><span class="comment"># 记录pid与日志的文件</span></span><br><span class="line">pidfile=uwsgi.pid</span><br><span class="line">daemonize=uwsgi.log</span><br></pre></td></tr></table></figure><h4 id="启动uwsgi"><a href="#启动uwsgi" class="headerlink" title="启动uwsgi"></a>启动uwsgi</h4><p>进入项目的第一层目录，这里有写好的uwsgi.ini文件，执行这个文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --ini  uwsgi.ini</span><br></pre></td></tr></table></figure><p>特别注意，这里用的都是相对路径~真正的执行命令其实是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/Envs/whw_di1/bin/uwsgi --ini /opt/whw/uwsgi.ini</span><br></pre></td></tr></table></figure><p>——这样的执行结果是在前台运行的，我们的终端会夯住，如果关掉这个终端uwsgi的进行也会关掉，需要我们再打开一个终端进行下一步的操作~<br><strong>——让uwsgi后台执行的话~只需要在命令里面加上-d参数就好了：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi -d --ini uwsgi.ini</span><br></pre></td></tr></table></figure><h3 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h3><p>nginx的配置文件是 /opt/tngx231/conf/nginx.conf 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里需要说明一下：</span></span><br><span class="line">如果安装的是nginx不是tengine，且没有指定安装目录，那么它的配置文件默认是 </span><br><span class="line">/etc/nginx目录中的nginx.conf文件</span><br></pre></td></tr></table></figure><p>编辑这个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/tngx231/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>我们只配置第一个server里面的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># 支持uwsgi的配置</span></span><br><span class="line">            include uwsgi_params;</span><br><span class="line">            <span class="comment"># ip与端口是uwsgi服务器的ip与端口~本例二者在一个机器里因此用环回地址</span></span><br><span class="line">            uwsgi_pass <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>;</span><br><span class="line">            <span class="comment">#root   html;</span></span><br><span class="line">            <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 存放静态文件的配置</span></span><br><span class="line">        location /static&#123;</span><br><span class="line">            alias /opt/whw_static;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment"># xxxxxxxxxxxxxxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx配置完后启动nginx服务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>如果中途修改了nginx.conf的参数的话，保存完后需要重启nginx服务，记得在重启前-t一下查看nginx的状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(whw_di1) [root@bogon whw]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /opt/tngx231//conf/nginx.conf syntax <span class="keyword">is</span> ok</span><br><span class="line">nginx: configuration file /opt/tngx231//conf/nginx.conf test <span class="keyword">is</span> successful</span><br><span class="line">(whw_di1) [root@bogon whw]<span class="comment"># </span></span><br><span class="line">(whw_di1) [root@bogon whw]<span class="comment"># nginx -s reload</span></span><br></pre></td></tr></table></figure><p>至此，项目部署的配置就这么多了。</p><h2 id="请求流程简介"><a href="#请求流程简介" class="headerlink" title="请求流程简介"></a>请求流程简介</h2><p>（1）用户发起请求<br>（2）访问IP(或者访问域名) 请求走到nginx这一层代理<br>（3）nginx直接转发(uwsgi_pass)给后端django的地址<br>（4）django处理完毕<br>（5）响应给nginx<br>（6）nginx返回结果给浏览器界面</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名后端开发的程序员不仅要会写业务代码、解决各种BUG、优化项目性能，也应该知道如何将自己写好的项目部署到服务器中让别人去访问。&lt;br&gt;本文详细讲解了用一台安装了CentOS7.5系统的裸奔Linux机器（虚拟机）从零开始部署django项目的过程。
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="项目部署" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Django中的信号signal</title>
    <link href="http://yoursite.com/2019/09/21/Django%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7signal/"/>
    <id>http://yoursite.com/2019/09/21/Django中的信号signal/</id>
    <published>2019-09-21T03:11:29.000Z</published>
    <updated>2019-09-21T08:32:19.224Z</updated>
    
    <content type="html"><![CDATA[<p>在真实的企业生产环境中，我们会遇到各种各样的需求，比如在全局对客户端请求进行过滤，将不满足某些条件的客户端请求过滤掉，这时我们可以利用Django的中间件来实现该需求；或者，我们希望每次model的save()方法被调用后，都要写一条日志到日志文件中，而此时我们可以通过Django提供的内置信号post_save来实现，本文介绍一下Django的高级功能——信号。<br>Django的“信号分发器”允许解耦的应用在框架的其它地方发生操作时会被通知到。 简单来说，信号允许特定的sender通知一组receiver某些操作已经发生。 这在多处代码和同一事件有关联的情况下很有用。<a id="more"></a></p><h3 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a><code>信号的概念</code></h3><p>Django2.1官文对signal的解释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Django includes a <span class="string">"signal dispatcher"</span> which helps allow decoupled applications get notified when actions occur elsewhere <span class="keyword">in</span> the framework.</span><br><span class="line">In a nutshell, signals allow certain senders to notify a set of receivers that some action has taken place. </span><br><span class="line">They are especially useful when many pieces of code may be interested <span class="keyword">in</span> the same events.</span><br></pre></td></tr></table></figure><p>翻译过来就是：Django框架内部包含了一个信号调度器，它的作用是可以将框架内部发生的任何操作都通知到功能独立的应用程序，当然，我们也可以缩小发送者和接收者的范围，即指定具体的发送者和接受者，假设我们的程序中有多个业务逻辑都在等待某一个事件发生之后再继续执行后面的代码，那么此时，信号是非常有用的。</p><h3 id="Django内置的信号"><a href="#Django内置的信号" class="headerlink" title="Django内置的信号"></a><code>Django内置的信号</code></h3><p><strong>Django内置的信号如下:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Model signals</span><br><span class="line">    pre_init                    <span class="comment"># django的model执行其构造方法前，自动触发</span></span><br><span class="line">    post_init                   <span class="comment"># django的model执行其构造方法后，自动触发</span></span><br><span class="line">    pre_save                    <span class="comment"># django的model对象保存前，自动触发</span></span><br><span class="line">    post_save                   <span class="comment"># django的model对象保存后，自动触发</span></span><br><span class="line">    pre_delete                  <span class="comment"># django的model对象删除前，自动触发</span></span><br><span class="line">    post_delete                 <span class="comment"># django的model对象删除后，自动触发</span></span><br><span class="line">    m2m_changed                 <span class="comment"># django的model中使用m2m字段操作第三张表（add,remove,clear）前后，自动触发</span></span><br><span class="line">    class_prepared              <span class="comment"># 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发</span></span><br><span class="line">Management signals</span><br><span class="line">    pre_migrate                 <span class="comment"># 执行migrate命令前，自动触发</span></span><br><span class="line">    post_migrate                <span class="comment"># 执行migrate命令后，自动触发</span></span><br><span class="line">Request/response signals</span><br><span class="line">    request_started             <span class="comment"># 请求到来前，自动触发</span></span><br><span class="line">    request_finished            <span class="comment"># 请求结束后，自动触发</span></span><br><span class="line">    got_request_exception       <span class="comment"># 请求异常后，自动触发</span></span><br><span class="line">Test signals</span><br><span class="line">    setting_changed             <span class="comment"># 使用test测试修改配置文件时，自动触发</span></span><br><span class="line">    template_rendered           <span class="comment"># 使用test测试渲染模板时，自动触发</span></span><br><span class="line">Database Wrappers</span><br><span class="line">    connection_created          <span class="comment"># 创建数据库连接时，自动触发</span></span><br></pre></td></tr></table></figure><h3 id="Django内置信号的使用"><a href="#Django内置信号的使用" class="headerlink" title="Django内置信号的使用"></a><code>Django内置信号的使用</code></h3><h4 id="注册内置信号"><a href="#注册内置信号" class="headerlink" title="注册内置信号"></a><code>注册内置信号</code></h4><p>对于Django内置的信号，仅需注册指定信号，当程序执行相应操作时，自动触发注册函数。注册信号，写入与project同名的文件夹下的<em>init</em>.py文件中，也是换数据库引擎的地方。<br><img src="http://whw.pythonav.cn/signal1.png" alt="2223"><br>如上图，项目名为signalTest，我们在与项目同名的包的<strong>init</strong>.py文件中注册Django内置的信号，然后使用就可以了。</p><h4 id="监听信号的2种方式"><a href="#监听信号的2种方式" class="headerlink" title="监听信号的2种方式"></a><code>监听信号的2种方式</code></h4><h5 id="直接监听"><a href="#直接监听" class="headerlink" title="直接监听"></a><code>直接监听</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"Request finished!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_finished</span><br><span class="line"></span><br><span class="line">request_finished.connect(my_callback)</span><br></pre></td></tr></table></figure><h5 id="使用装饰器监听"><a href="#使用装饰器监听" class="headerlink" title="使用装饰器监听"></a><code>使用装饰器监听</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"Request finished!"</span>)</span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_finished</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(request_finished)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"Request finished!"</span>)</span><br></pre></td></tr></table></figure><h4 id="注册时指定发送者"><a href="#注册时指定发送者" class="headerlink" title="注册时指定发送者"></a><code>注册时指定发送者</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> MyModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在MyModel对应的数据保存前执行my_handler函数</span></span><br><span class="line"><span class="meta">@receiver(pre_save, sender=MyModel)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><p><code>注册完内置信号后，只要满足触发条件，对应的函数会在相应的条件下去执行，不用人手动去调用。</code></p><h3 id="内置信号详细介绍"><a href="#内置信号详细介绍" class="headerlink" title="内置信号详细介绍"></a><code>内置信号详细介绍</code></h3><p>更多内置信号的说明请参考这篇博客：<a href="https://www.cnblogs.com/liwenzhou/p/9745331.html" target="_blank" rel="noopener">https://www.cnblogs.com/liwenzhou/p/9745331.html</a></p><h3 id="自定义信号的使用"><a href="#自定义信号的使用" class="headerlink" title="自定义信号的使用"></a><code>自定义信号的使用</code></h3><p>首先要知道的是，我们用的信号都是<strong>django.dispatch.Signal</strong>这个类的实例。</p><h4 id="首先定义信号"><a href="#首先定义信号" class="headerlink" title="首先定义信号"></a><code>首先定义信号</code></h4><p>在任意的py文件中定义信号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line">signal_done = django.dispatch.Signal(providing_args=[<span class="string">"height"</span>, <span class="string">"width"</span>])</span><br></pre></td></tr></table></figure><h4 id="然后在与项目同名的包的-init-文件中注册信号"><a href="#然后在与项目同名的包的-init-文件中注册信号" class="headerlink" title="然后在与项目同名的包的__init__文件中注册信号"></a><code>然后在与项目同名的包的__init__文件中注册信号</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"callback"</span>)</span><br><span class="line">    print(sender,kwargs)</span><br><span class="line"> </span><br><span class="line">signal_done.connect(callback)</span><br></pre></td></tr></table></figure><h4 id="最后在需要触发信号的地方使用自定义信号"><a href="#最后在需要触发信号的地方使用自定义信号" class="headerlink" title="最后在需要触发信号的地方使用自定义信号"></a><code>最后在需要触发信号的地方使用自定义信号</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 路径 <span class="keyword">import</span> signal_done</span><br><span class="line"> </span><br><span class="line">signal_done.send(sender=<span class="string">'Naruto'</span>,height=<span class="number">123</span>, width=<span class="number">456</span>)</span><br></pre></td></tr></table></figure><p><code>最后需要注意：由于内置信号的触发者已经集成到Django中，所以其会自动调用；而对于自定义信号则需要开发者在对应位置指定触发。</code></p><h3 id="在路由分发前注册信号的方法"><a href="#在路由分发前注册信号的方法" class="headerlink" title="在路由分发前注册信号的方法"></a><code>在路由分发前注册信号的方法</code></h3><p>上面介绍的一种方式是<strong>在项目同名的包的<code>__init__.py</code>文件中去注册信号</strong>。<br>我们也可以利用Django在路由分发之前做一下信号的注册操作。<br>这里用到了Django启动的机制：<strong>django.dispatch.Signal在django.setup()的过程中，它会遍历settings.INSTALLED_APPS列表中的每一项，并调用该AppConfig的ready方法，因此，将recevier订阅signal的过程放置于ready方法中就能保证该代码的执行。</strong><br>我们来拿一个具体的项目为例。</p><h4 id="项目的目录结构如下"><a href="#项目的目录结构如下" class="headerlink" title="项目的目录结构如下"></a><code>项目的目录结构如下</code></h4><p><img src="http://whw.pythonav.cn/signal3.png" alt="22331"><br><code>（1）把所有的信号都写在了signals包中，并且signals包中的__init__.py文件中实例化Signal类的对象（注意Python在import一个包的时候会执行里面的__init__文件），执行的操作我写在了handlers.py文件中；</code><br><code>（2）然后，利用Django的启动的原理，我把信号的注册写在了apps.py的SignalappConfig类的ready方法中，保证在路由分发之前就注册自定义的信号。</code></p><h4 id="注册信号的具体写法"><a href="#注册信号的具体写法" class="headerlink" title="注册信号的具体写法"></a><code>注册信号的具体写法</code></h4><h5 id="signals-init-py"><a href="#signals-init-py" class="headerlink" title="signals/__init__.py"></a><code>signals/__init__.py</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line"></span><br><span class="line">my_signal = Signal(providing_args=[])</span><br></pre></td></tr></table></figure><h5 id="signals-handlers-py："><a href="#signals-handlers-py：" class="headerlink" title="signals/handlers.py："></a><code>signals/handlers.py：</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(sender,**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'my_callback...'</span>)</span><br></pre></td></tr></table></figure><h5 id="signalapp-apps-py"><a href="#signalapp-apps-py" class="headerlink" title="signalapp/apps.py"></a><code>signalapp/apps.py</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从外部导入自定义信号及处理的函数</span></span><br><span class="line"><span class="keyword">from</span> signals <span class="keyword">import</span> my_signal</span><br><span class="line"><span class="keyword">from</span> signals.handlers <span class="keyword">import</span> my_callback</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalappConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'signalapp'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 注册信号</span></span><br><span class="line">        my_signal.connect(my_callback)</span><br></pre></td></tr></table></figure><h4 id="使用自定义的信号"><a href="#使用自定义的信号" class="headerlink" title="使用自定义的信号"></a><code>使用自定义的信号</code></h4><p>做一个简单的路由与视图测试一下这个自定义的信号是否成功：</p><h5 id="signalTest-urls-py"><a href="#signalTest-urls-py" class="headerlink" title="signalTest/urls.py"></a><code>signalTest/urls.py</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> signalapp <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'index/'</span>,views.index,name=<span class="string">'index'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="sjgnalapp-views-py"><a href="#sjgnalapp-views-py" class="headerlink" title="sjgnalapp/views.py"></a><code>sjgnalapp/views.py</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="comment"># 导入自定义信号的处理函数</span></span><br><span class="line"><span class="keyword">from</span> signals.handlers <span class="keyword">import</span> my_callback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 使用自定义信号</span></span><br><span class="line">    my_callback(sender=<span class="string">'index'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure><p>启动Django程序后我们在浏览器中输入127.0.0.1:8000/index，可以看到在后台打印出了自定义信号处理函数中所打印的数据： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_callback...</span><br></pre></td></tr></table></figure><h3 id="定制信号的发送者"><a href="#定制信号的发送者" class="headerlink" title="定制信号的发送者"></a><code>定制信号的发送者</code></h3><p>默认情况下，某些信号会被多次发送，但是，通常，我们只希望接收某个或者某些特定的发送者发出的信号，比如说django.db.models.signals.pre_saves，该信号，它在每个model的save()方法被执行的时候被发送，不过，很多情况下，我们只想记录某个特定的model的save()方法被执行时的日志。<br>在上述情况下，我们可以指定只接受我们指定的信号发送者发出的信号。<br>还是用django.db.models.signals.pre_saves举例，下面我们来演示如何指定发送者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> MyModel</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(pre_save, sender=MyModel)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><h3 id="断开信号"><a href="#断开信号" class="headerlink" title="断开信号"></a><code>断开信号</code></h3><p>如果不希望再接收某个信号，我们可以调用<code>Signal.disconnect()</code>方法。</p><h3 id="更多内容详见官网文档"><a href="#更多内容详见官网文档" class="headerlink" title="更多内容详见官网文档"></a><code>更多内容详见官网文档</code></h3><p><a href="https://docs.djangoproject.com/zh-hans/2.1/topics/signals/" target="_blank" rel="noopener">Django2.1信号signal文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真实的企业生产环境中，我们会遇到各种各样的需求，比如在全局对客户端请求进行过滤，将不满足某些条件的客户端请求过滤掉，这时我们可以利用Django的中间件来实现该需求；或者，我们希望每次model的save()方法被调用后，都要写一条日志到日志文件中，而此时我们可以通过Django提供的内置信号post_save来实现，本文介绍一下Django的高级功能——信号。&lt;br&gt;Django的“信号分发器”允许解耦的应用在框架的其它地方发生操作时会被通知到。 简单来说，信号允许特定的sender通知一组receiver某些操作已经发生。 这在多处代码和同一事件有关联的情况下很有用。
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="信号signal" scheme="http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7signal/"/>
    
  </entry>
  
  <entry>
    <title>Pycharm与Python3中的TypeHint</title>
    <link href="http://yoursite.com/2019/08/30/Pycharm%E4%B8%8EPython3%E4%B8%AD%E7%9A%84TypeHint/"/>
    <id>http://yoursite.com/2019/08/30/Pycharm与Python3中的TypeHint/</id>
    <published>2019-08-30T14:23:34.000Z</published>
    <updated>2019-09-21T04:28:21.223Z</updated>
    
    <content type="html"><![CDATA[<p>也许有很多同学跟我一样一直使用Pycharm这个IDE作为主要的开发工具。但是在大型项目中Python这门动态语言本身并没有像C++/Java那样的类型声明的限制，这会导致我们在review代码或者接手别人的代码时产生很多困难。<br>还好自python3.5开始，PEP484为python引入了类型提示(TypeHint)。<br>类型提示是一种可以将你的函数变量声明为一种特定类型的声明。当然，类型提示并不是绑定，它仅仅是暗示，所以这种机制并不能阻止工程师传入他们不应该传入的参数。但是个人认为TypeHint是Python非常贴心的一个改进，因为添加了类型提示后，我们仅仅通过观察函数的定义就可以知道变量应该是什么类型。<br>另外需要注意Pycharm一定要用2017或更高的版本，否则你可能看不到Pycharm关于“类型错误”的提示。<a id="more"></a></p><h3 id="类型提示的使用"><a href="#类型提示的使用" class="headerlink" title="类型提示的使用"></a>类型提示的使用</h3><p>不管是函数中传入的参数还是其返回值，基本上都会包括以下4类：</p><ul><li><strong>基本内置类型，如 str，int，list</strong></li><li><strong>基本类型组合产生的复杂类型，如 list[int], dict[str, int]</strong></li><li><strong>用户自定的class作为类型提示</strong></li><li><strong>函数参数，即 callable，比如回调参数：(value: str, index: int) -&gt; str</strong><h4 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h4>基本内置类型的提示很简单，只需要在函数定义阶段规定参数的类型及返回值类型即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_hint</span><span class="params">(a:int,b:int)</span>-&gt;int:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">print(int_hint(<span class="number">11</span>,<span class="number">22</span>))</span><br><span class="line"><span class="comment"># 程序本身不会报错，但是Pycharm会有提示</span></span><br><span class="line">print(int_hint(<span class="string">'aa'</span>,<span class="string">'bb'</span>))</span><br></pre></td></tr></table></figure></li></ul><p>我们来看一下实际中Pycharm的提示：<br><img src="http://whw.pythonav.cn/1.png" alt="tishi1"></p><h4 id="基本类型组合产生的复杂类型"><a href="#基本类型组合产生的复杂类型" class="headerlink" title="基本类型组合产生的复杂类型"></a>基本类型组合产生的复杂类型</h4><p>这里我们需要使用Python的<code>typing</code>模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_hint</span><span class="params">(x:typing.List[str],y:typing.List[str])</span>-&gt;typing.Dict[str,typing.List[str]]:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'x'</span>:x,</span><br><span class="line">        <span class="string">'y'</span>:y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">a = [<span class="string">'a1'</span>]</span><br><span class="line">b = [<span class="string">'b1'</span>]</span><br><span class="line"></span><br><span class="line">print(my_hint(a,b))</span><br></pre></td></tr></table></figure><p>由上面的代码可知：<code>my_hint</code>函数接收2个参数，分别是列表里面嵌套一个字符串，它的返回值是一个字典，并且这个字典的key是str类型，value是列表嵌套字符串类型的值。<br>上面代码的结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'x'</span>: [<span class="string">'a1'</span>], <span class="string">'y'</span>: [<span class="string">'b1'</span>]&#125;</span><br></pre></td></tr></table></figure><h4 id="用户自定的class作为类型提示"><a href="#用户自定的class作为类型提示" class="headerlink" title="用户自定的class作为类型提示"></a>用户自定的class作为类型提示</h4><p>我们来看一下这个面向对象的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(name:People)</span>-&gt;<span class="keyword">None</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; is singing...'</span>.format(name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(name:Dog)</span>-&gt;<span class="keyword">None</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; is barking...'</span>.format(name))</span><br><span class="line"></span><br><span class="line">Tom = People(<span class="string">'Tom'</span>)</span><br><span class="line">Jerry = Dog(<span class="string">'Jerry'</span>)</span><br><span class="line"></span><br><span class="line">sing(Tom)</span><br><span class="line"><span class="comment"># Pycharm也会有提示</span></span><br><span class="line">sing(Jerry)</span><br><span class="line">bark(Jerry)</span><br></pre></td></tr></table></figure><p>sing函数需要传入一个People对象，但是实际中传入的是一个Dog类实例化的对象，Pycharm也会提示：<br><img src="http://whw.pythonav.cn/2.png" alt="xsa"></p><h4 id="函数参数-callable"><a href="#函数参数-callable" class="headerlink" title="函数参数 callable"></a>函数参数 callable</h4><p><strong>这种情况是将一个函数作为参数实现参数的回调：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dic</span><span class="params">(name:str,age:int)</span>-&gt;dict:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'name'</span>:name,</span><br><span class="line">        <span class="string">'age'</span>:age   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callable</span><span class="params">(name:str,age:int,callback:typing.Callable[[str,int],dict])</span>:</span></span><br><span class="line">    ret = callback(name,age)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将create_dict函数传进去，注意是在my_callable函数中执行</span></span><br><span class="line">print(my_callable(<span class="string">'wanghw'</span>,<span class="number">18</span>,create_dic))</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'wanghw'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>当然，这种方式在实际中使用的并不多，但是遇到的话我们也应该能够读懂代码。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.im/post/5a8ed8f9f265da4e6e2bd920" target="_blank" rel="noopener"><a href="https://juejin.im/post/5a8ed8f9f265da4e6e2bd920" target="_blank" rel="noopener">https://juejin.im/post/5a8ed8f9f265da4e6e2bd920</a></a><br><a href="https://www.cnblogs.com/sddai/p/11458757.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/sddai/p/11458757.html" target="_blank" rel="noopener">https://www.cnblogs.com/sddai/p/11458757.html</a></a><br><a href="https://www.cnblogs.com/zhbzz2007/p/6200515.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/zhbzz2007/p/6200515.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhbzz2007/p/6200515.html</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许有很多同学跟我一样一直使用Pycharm这个IDE作为主要的开发工具。但是在大型项目中Python这门动态语言本身并没有像C++/Java那样的类型声明的限制，这会导致我们在review代码或者接手别人的代码时产生很多困难。&lt;br&gt;还好自python3.5开始，PEP484为python引入了类型提示(TypeHint)。&lt;br&gt;类型提示是一种可以将你的函数变量声明为一种特定类型的声明。当然，类型提示并不是绑定，它仅仅是暗示，所以这种机制并不能阻止工程师传入他们不应该传入的参数。但是个人认为TypeHint是Python非常贴心的一个改进，因为添加了类型提示后，我们仅仅通过观察函数的定义就可以知道变量应该是什么类型。&lt;br&gt;另外需要注意Pycharm一定要用2017或更高的版本，否则你可能看不到Pycharm关于“类型错误”的提示。
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Pycharm" scheme="http://yoursite.com/tags/Pycharm/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask的版本与返回字典数据的问题</title>
    <link href="http://yoursite.com/2019/08/10/Flask%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/10/Flask的版本与返回字典数据的问题/</id>
    <published>2019-08-10T01:33:59.000Z</published>
    <updated>2019-09-21T04:28:21.222Z</updated>
    
    <content type="html"><![CDATA[<p>以往我们用flask返回一个字典的时候都会先用<code>jsonify</code>方法把这个字典序列化一下再返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">dic = &#123;<span class="string">"name"</span>:<span class="string">"whw"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">return</span> jsonify(dic)</span><br></pre></td></tr></table></figure><a id="more"></a>如果直接返回字典的话会报一个`TypeError`的错误！<p><img src="http://whw.pythonav.cn/f1.png" alt="123"><br>如果访问<code>index</code>的话会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError:<span class="string">'dict'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure><h3 id="1-1-1版本的flask可以直接返回字典"><a href="#1-1-1版本的flask可以直接返回字典" class="headerlink" title="1.1.1版本的flask可以直接返回字典"></a>1.1.1版本的flask可以直接返回字典</h3><p>但是，最近发现了一个十分奇妙的问题：1.11版本的flask是可以直接返回字典的：<br><img src="http://whw.pythonav.cn/f2.png" alt="222"><br>可以访问<code>index</code>看一下结果，字典被成功返回了！<br><img src="http://whw.pythonav.cn/f3.png" alt="333"><br>很神奇，看来flask改版以后优化了返回的数据的结构！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以往我们用flask返回一个字典的时候都会先用&lt;code&gt;jsonify&lt;/code&gt;方法把这个字典序列化一下再返回：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Flask,jsonify&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&quot;/&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;home&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dic = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;whw&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jsonify(dic)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Flask" scheme="http://yoursite.com/categories/Flask/"/>
    
    
      <category term="Flask基础" scheme="http://yoursite.com/tags/Flask%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Python中字典的打散传参</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B5%85%E8%B0%88Python%E4%B8%AD%E5%AD%97%E5%85%B8%E7%9A%84%E6%89%93%E6%95%A3%E4%BC%A0%E5%8F%82/"/>
    <id>http://yoursite.com/2019/08/09/浅谈Python中字典的打散传参/</id>
    <published>2019-08-09T08:56:59.000Z</published>
    <updated>2019-09-21T04:28:21.225Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发中我们常会遇到将用户提交的数据经过校验后存入数据库的操作。<br>假设用户使用form表单以post方式往Customer表中提交数据，后台接收到数据后往往会这样进行处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将csrf校验的键值对去除</span></span><br><span class="line">request.POST.pop(<span class="string">"csrfmiddlewaretoken"</span>)</span><br><span class="line"><span class="comment"># 以打散的方式将数据传入数据库的表中</span></span><br><span class="line">Customer.objects.update_or_create(**request.POST)</span><br></pre></td></tr></table></figure><p>我们知道，request.POST是一个<code>QueryDict</code>对象，实际上它是一个自定义的<code>字典</code>，除了修改的时候需要注意其<code>不可变特性</code>以外，在进行传参的时候我们可以把它当作一个字典。<br>而且需要注意的是，这种“打散”的方式传参要求这个<code>字典</code>中的所有的<code>key</code>必须跟数据库的表中的字段的名字一致！否则传参的时候会发生错误！<a id="more"></a></p><h4 id="一个小demo解释字典打散传参的机理"><a href="#一个小demo解释字典打散传参的机理" class="headerlink" title="一个小demo解释字典打散传参的机理"></a>一个小demo解释字典打散传参的机理</h4><p>那么问题来了：这种<code>打散</code>的方式的机制是什么呢？<br>来看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(username,password)</span>:</span></span><br><span class="line"><span class="keyword">global</span> count</span><br><span class="line">print(count,username,password)</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">dic = &#123;<span class="string">"username"</span>:<span class="string">'whw'</span>,<span class="string">'password'</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="comment"># 打散传参与位置参数传参</span></span><br><span class="line">func(**dic)</span><br><span class="line">func(username=<span class="string">'whw'</span>,password=<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>执行的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> whw <span class="number">123</span></span><br><span class="line"><span class="number">2</span> whw <span class="number">123</span></span><br></pre></td></tr></table></figure><p>首先，我们先定义了一个函数<code>func</code>，里面有两个位置参数username与password，然后又定义了一个字典<code>dic={&quot;username&quot;:&quot;whw&quot;,&quot;password&quot;:123}</code>，count变量作为一个计数器使用。<br>然后，执行func函数的时候我们采用了两种方式去传参：一种只<code>**dic</code>方式，也就是将dic打散；另外一种是常规的传参方式。<br>两种方式都正常执行，说明上述两种传参方式是等价的！<br>也就是说：<code>**dic</code>将字典<code>打散</code>成了一个个的<code>key=value</code>的形式！<br>另外，还需要特别注意的一点是：这种传参的方式对字典的key是有要求的，被打散的字典的key值必须与函数的位置参数的值一致，否则程序会报错！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发中我们常会遇到将用户提交的数据经过校验后存入数据库的操作。&lt;br&gt;假设用户使用form表单以post方式往Customer表中提交数据，后台接收到数据后往往会这样进行处理：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 将csrf校验的键值对去除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.POST.pop(&lt;span class=&quot;string&quot;&gt;&quot;csrfmiddlewaretoken&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 以打散的方式将数据传入数据库的表中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Customer.objects.update_or_create(**request.POST)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们知道，request.POST是一个&lt;code&gt;QueryDict&lt;/code&gt;对象，实际上它是一个自定义的&lt;code&gt;字典&lt;/code&gt;，除了修改的时候需要注意其&lt;code&gt;不可变特性&lt;/code&gt;以外，在进行传参的时候我们可以把它当作一个字典。&lt;br&gt;而且需要注意的是，这种“打散”的方式传参要求这个&lt;code&gt;字典&lt;/code&gt;中的所有的&lt;code&gt;key&lt;/code&gt;必须跟数据库的表中的字段的名字一致！否则传参的时候会发生错误！
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>浅析Django的settings配置原理</title>
    <link href="http://yoursite.com/2019/08/08/%E6%B5%85%E6%9E%90Django%E7%9A%84settings%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/08/浅析Django的settings配置原理/</id>
    <published>2019-08-08T13:02:01.000Z</published>
    <updated>2019-09-21T04:28:21.225Z</updated>
    
    <content type="html"><![CDATA[<p>Django的settings.py文件是每个django项目必用的配置文件。其实项目的二级目录下的这个settings.py文件仅是用户级别的一个配置文件，在django的内部还有一个<code>global_settings.py</code>文件。这是一个全局的默认配置的文件，django所有的默认配置其实在这个文件中。<br>在实际的开发中，程序员可以在二级目录下的settings.py文件中配置自己需要的信息，比如SESSION_KEY等等；当然你的配置也可以与默认配置文件中的内容相同，比如session的生存周期<code>SESSION_COOKIE_AGE</code>等等，这种情况下django会优先用户的配置。<br>需要注意的是，配置文件中的变量必须全部是大写，否则django不会识别这个配置项的。<br>那么，django内部是如何实现上述这样的效果的呢？本文用一个简单的例子为大家详细解析一下django内部实现的过程。<a id="more"></a></p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>​新创建一个项目，项目的目录结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SettingsTest</span><br><span class="line">├── bin <span class="comment"># 项目启动目录                          </span></span><br><span class="line">│   └── start.py</span><br><span class="line">├── conf <span class="comment"># 存放用户配置的目录</span></span><br><span class="line">│   └── settings.py</span><br><span class="line">├── lib</span><br><span class="line">│   └── conf </span><br><span class="line">│       ├── __init__.py <span class="comment"># 实现用户与默认配置的逻辑</span></span><br><span class="line">│       └── global_settings.py <span class="comment"># 项目的默认配置</span></span><br><span class="line">└── src </span><br><span class="line">    └── script.py <span class="comment"># 处理业务逻辑的入口</span></span><br></pre></td></tr></table></figure><h3 id="具体代码及说明如下"><a href="#具体代码及说明如下" class="headerlink" title="具体代码及说明如下"></a>具体代码及说明如下</h3><h5 id="start文件的内容如下"><a href="#start文件的内容如下" class="headerlink" title="start文件的内容如下"></a>start文件的内容如下</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># start.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到当前项目的根目录的绝对路径并加入解释器的path中</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.insert(<span class="number">0</span>,BASE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># 将用户配置文件的相对路径传入os.environ中。</span></span><br><span class="line"><span class="comment"># 注意要在run导入之前设置</span></span><br><span class="line">os.environ[<span class="string">'USER_SETTINGS'</span>] = <span class="string">'conf.settings'</span></span><br><span class="line"><span class="comment"># 导入自定义模块</span></span><br><span class="line"><span class="keyword">from</span> src.script <span class="keyword">import</span> run</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>start文件是程序的入口，需要将项目的根目录加入到编译环境的path中。在<code>os.envision</code>中加入用户配置文件的相对路径为后面的操作做铺垫。</p><h5 id="用户配置文件settings中的内容如下"><a href="#用户配置文件settings中的内容如下" class="headerlink" title="用户配置文件settings中的内容如下"></a>用户配置文件settings中的内容如下</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line">NAME = <span class="string">'wanghw'</span></span><br><span class="line">AGE = <span class="number">18</span></span><br></pre></td></tr></table></figure><h5 id="全局配置文件global-settings中的内容如下"><a href="#全局配置文件global-settings中的内容如下" class="headerlink" title="全局配置文件global_settings中的内容如下"></a>全局配置文件global_settings中的内容如下</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># global_settings.py</span></span><br><span class="line"></span><br><span class="line">NAME = <span class="string">''</span></span><br><span class="line">AGE = <span class="literal">None</span></span><br><span class="line">EMAIL = <span class="string">'xxx@xxx.com'</span></span><br></pre></td></tr></table></figure><p>可以看到，用户的配置跟默认配置里的<code>NAME</code> 与<code>AGE</code>重复了。我们最终实现的效果是：<code>重复的变量展示用户配置的，用户配置里没有的展示默认配置的变量的值。</code></p><h5 id="lib目录下的conf文件夹中的init文件里的代码如下"><a href="#lib目录下的conf文件夹中的init文件里的代码如下" class="headerlink" title="lib目录下的conf文件夹中的init文件里的代码如下"></a>lib目录下的conf文件夹中的<strong>init</strong>文件里的代码如下</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 实现用户与默认配置的逻辑</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> global_settings</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 默认配置</span></span><br><span class="line">        <span class="comment"># dir获取对象的属性</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dir(global_settings):  </span><br><span class="line">        <span class="comment"># 只获取大写的变量</span></span><br><span class="line">            <span class="keyword">if</span> i.isupper():  </span><br><span class="line">            <span class="comment"># 通过反射获取值：getattr</span></span><br><span class="line">                v = getattr(global_settings, i)  </span><br><span class="line">                <span class="comment"># 给settings对象本身设置值：setattr</span></span><br><span class="line">                setattr(self, i, v)  </span><br><span class="line"></span><br><span class="line">        <span class="comment">#  用户自定义的配置：'conf.settings'</span></span><br><span class="line">        path = os.environ.get(<span class="string">'USER_SETTINGS'</span>)</span><br><span class="line">        <span class="comment"># 导入用户的自定义的配置 </span></span><br><span class="line">        module = importlib.import_module(path)  </span><br><span class="line">        <span class="comment"># dir获取对象的属性</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dir(module):  </span><br><span class="line">        <span class="comment"># 只获取大写的变量</span></span><br><span class="line">            <span class="keyword">if</span> i.isupper():</span><br><span class="line">            <span class="comment"># 通过反射获取值：getattr</span></span><br><span class="line">                v = getattr(module, i) </span><br><span class="line">                 <span class="comment"># 给settings对象本身设置值：setattr</span></span><br><span class="line">                setattr(self, i, v) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象，我们后续导入的其实是这个对象</span></span><br><span class="line">settings = Settings()</span><br></pre></td></tr></table></figure><p><strong>需要重点说一下这里：</strong></p><ul><li><p>根据Python包导入的原理：导入一个包其实执行了这个包里的<strong>init</strong>.py文件，因此在外部引入lib.conf的话会执行conf包里面的<strong>init</strong>.py文件中的内容。</p></li><li><p>先不看类的初始化方法实现的逻辑，在代码块的最后一行我们实例化了一个Settings类的对象——我们其实是把所有的配置信息<code>封装</code>到了settings对象中了！</p></li><li><p>最后看一下具体的实现逻辑：实例化Settings类的时候执行里面的<strong>init</strong>方法，首先通过getattr方法获取默认配置文件中的配置信息，并通过setattr将默认配置的数据封装到类的对象中；然后根据<code>os.envision</code>中的键值对找到用户配置文件的位置，利用<code>importlib方法</code>找到这个模块，首先通过getattr方法获取用户配置文件中的配置信息，并通过setattr将默认配置的数据封装到类的对象中。</p></li><li><p>可以看到：给对象封装数据的顺序是先封装默认配置数据再封装用户配置的数据，这样实现了<code>用户配置优先</code>的效果。</p><h5 id="负责业务处理的script文件中的内容如下"><a href="#负责业务处理的script文件中的内容如下" class="headerlink" title="负责业务处理的script文件中的内容如下"></a>负责业务处理的script文件中的内容如下</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># script.py</span></span><br><span class="line"><span class="comment"># 需要注意，这里引用的是settings对象</span></span><br><span class="line"><span class="keyword">from</span> lib.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">print(settings.NAME)</span><br><span class="line">print(settings.AGE)</span><br><span class="line">print(settings.EMAIL)</span><br></pre></td></tr></table></figure></li><li><p>需要特别注意，我们引入的配置文件其实是一个<code>settings对象</code></p></li></ul><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><p>scripts文件中打印了三个变量，NAME、AGE与EMAIL，其中NAME与AGE是两个配置文件中都有的，EMAIL只在默认配置文件中有，我们看一下最后的打印效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wanghw</span><br><span class="line"><span class="number">18</span></span><br><span class="line">xxx@xxx.com</span><br></pre></td></tr></table></figure><p>这个结果与我们之前预想的一样：优先用户配置文件中的变量，用户配置文件中没有的变量去默认配置中找。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django的settings.py文件是每个django项目必用的配置文件。其实项目的二级目录下的这个settings.py文件仅是用户级别的一个配置文件，在django的内部还有一个&lt;code&gt;global_settings.py&lt;/code&gt;文件。这是一个全局的默认配置的文件，django所有的默认配置其实在这个文件中。&lt;br&gt;在实际的开发中，程序员可以在二级目录下的settings.py文件中配置自己需要的信息，比如SESSION_KEY等等；当然你的配置也可以与默认配置文件中的内容相同，比如session的生存周期&lt;code&gt;SESSION_COOKIE_AGE&lt;/code&gt;等等，这种情况下django会优先用户的配置。&lt;br&gt;需要注意的是，配置文件中的变量必须全部是大写，否则django不会识别这个配置项的。&lt;br&gt;那么，django内部是如何实现上述这样的效果的呢？本文用一个简单的例子为大家详细解析一下django内部实现的过程。
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django原理" scheme="http://yoursite.com/tags/Django%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Markdown中折叠代码的方法</title>
    <link href="http://yoursite.com/2019/08/04/Markdown%E4%B8%AD%E6%8A%98%E5%8F%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/04/Markdown中折叠代码的方法/</id>
    <published>2019-08-04T15:52:01.000Z</published>
    <updated>2019-09-21T04:28:21.222Z</updated>
    
    <content type="html"><![CDATA[<p>​    Markdown的代码折叠问题一直困扰了我好久，最近在机缘巧合之下终于找到了正确的方法！但是，由于这种方法是用html5的details标签做的，因此折叠的代码无法高亮显示。从“代码高亮”这个角度讲，这种方式与富文本编辑器的代码折叠相比确实略逊一筹。不过实际中如何取舍还是看大家的具体需求吧。<a id="more"></a></p><h3 id="语法如下："><a href="#语法如下：" class="headerlink" title="语法如下："></a>语法如下：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;点我展开看代码&lt;/summary&gt;</span><br><span class="line">  &lt;pre&gt;&lt;code&gt;</span><br><span class="line"><span class="comment"># 在这里写折叠的代码</span></span><br><span class="line">  &lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">details：折叠语法标签</span><br><span class="line">summary：折叠语法展示的摘要</span><br><span class="line">pre：以原有格式显示元素内的文字是已经格式化的文本</span><br><span class="line">code：指定代码块</span><br></pre></td></tr></table></figure><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><h4 id="折叠的代码如下："><a href="#折叠的代码如下：" class="headerlink" title="折叠的代码如下："></a>折叠的代码如下：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;点我展开看代码&lt;/summary&gt;</span><br><span class="line">  &lt;pre&gt;&lt;code&gt;</span><br><span class="line"><span class="comment"># 生成随机的11位数字组成的字符串</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">digits = string.digits</span><br><span class="line">print(digits) <span class="comment"># 0123456789</span></span><br><span class="line"></span><br><span class="line">s = random.choices(digits,k=<span class="number">11</span>)</span><br><span class="line">print(<span class="string">''</span>.join(s)) <span class="comment"># 11124861574</span></span><br><span class="line">  &lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h4 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h4><details>  <summary>点我展开看代码</summary>  <pre><code># 生成随机的11位数字组成的字符串import stringimport random<p>digits = string.digits<br>print(digits) # 0123456789</p><p>s = random.choices(digits,k=11)<br>print(‘’.join(s)) # 11124861574<br>  </p></code></pre><p></p></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    Markdown的代码折叠问题一直困扰了我好久，最近在机缘巧合之下终于找到了正确的方法！但是，由于这种方法是用html5的details标签做的，因此折叠的代码无法高亮显示。从“代码高亮”这个角度讲，这种方式与富文本编辑器的代码折叠相比确实略逊一筹。不过实际中如何取舍还是看大家的具体需求吧。
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Python中类的归一化设计</title>
    <link href="http://yoursite.com/2019/07/18/Python%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%BD%92%E4%B8%80%E5%8C%96%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/07/18/Python中类的归一化设计/</id>
    <published>2019-07-18T14:13:01.000Z</published>
    <updated>2019-09-21T04:28:21.223Z</updated>
    
    <content type="html"><![CDATA[<p>Python面向对象中的<code>abc模块</code>为我们提供了一种抽象类的归一化设计，把抽象类作为父类可以限制子类必须实现某些方法。<br>具体实现的方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">son = Son()</span><br></pre></td></tr></table></figure><a id="more"></a><p>抽象类Father在定义的时候指定其元类为<code>abc.ABCMeta</code>，里面的run方法用装饰器<code>abc.abstractmethod</code>装饰，这样所有继承它的子类就必须实现run这个方法。<br>上述代码中Son类继承了Father类但是没有实现其父类的run方法，<code>在Son类实例化对象的时候会抛出下列异常:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Can<span class="string">'t instantiate abstract class Son with abstract methods run</span></span><br></pre></td></tr></table></figure><p>我们在子类中必须实现run方法才能使程序正常运行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'run'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">son = Son()</span><br></pre></td></tr></table></figure><h4 id="异常处理的方式实现归一化效果"><a href="#异常处理的方式实现归一化效果" class="headerlink" title="异常处理的方式实现归一化效果"></a>异常处理的方式实现归一化效果</h4><p>利用<code>abc模块</code>实现的归一化设计是在子类<code>实例化</code>的时候进行判断的，这种方式难免有些强制，我平时比较常用<code>异常处理</code>的方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> NotImplementedError(<span class="string">"must have method run()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">son = Son()</span><br><span class="line">son.run()</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出：在实例化son对象的时候不会发生异常，但是在son试图调用run方法的时候，根据对象的属性与方法的查找顺序的原理可知，由于Son类本身没有实现run方法，只能从父类中去找，而父类的run方法会直接抛出异常！同样也实现了<code>强制子类必须定义run方法</code>的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python面向对象中的&lt;code&gt;abc模块&lt;/code&gt;为我们提供了一种抽象类的归一化设计，把抽象类作为父类可以限制子类必须实现某些方法。&lt;br&gt;具体实现的方法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; abc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Father&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(metaclass=abc.ABCMeta)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;	@abc.abstractmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Father)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	son = Son()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用Python的traceback模块显示与记录异常</title>
    <link href="http://yoursite.com/2019/05/17/%E5%88%A9%E7%94%A8Python%E7%9A%84traceback%E6%A8%A1%E5%9D%97%E6%98%BE%E7%A4%BA%E4%B8%8E%E8%AE%B0%E5%BD%95%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/05/17/利用Python的traceback模块显示与记录异常/</id>
    <published>2019-05-17T13:13:01.000Z</published>
    <updated>2019-09-21T04:28:21.224Z</updated>
    
    <content type="html"><![CDATA[<p>与异常做斗争已经是程序员的家常便饭了。很多时候我们需要将所有异常信息打印出来。比较通用的方法是直接利用异常去捕获：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"错误出现"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        error_func()</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'继续执行'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>打印的结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误出现</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure><p>但是，上面的代码只是打印了异常信息，并没有打印异常的类型。如果我们项目中异常处理的情况多的话就需要连同<code>异常出现的位置</code>、<code>异常信息</code>、<code>异常的类型</code>都打印出来，帮助我们排查错误。</p><h3 id="利用traceback模块的format-exc方法打印完整的异常"><a href="#利用traceback模块的format-exc方法打印完整的异常" class="headerlink" title="利用traceback模块的format_exc方法打印完整的异常"></a>利用traceback模块的format_exc方法打印完整的异常</h3><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"错误出现"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        error_func()</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">import</span> traceback</span><br><span class="line">        print(traceback.format_exc())</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'继续执行'</span>)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"D:/auto/pro/error_test.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    error_func()</span><br><span class="line">  File <span class="string">"D:/auto/pro/error_test.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> error_func</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"错误出现"</span>)</span><br><span class="line">ValueError: 错误出现</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure><p>这样，我们可以将完整的异常都打印出来，可以帮助我们分析错误原因。</p><h3 id="print-exc方法将错误信息写入日志"><a href="#print-exc方法将错误信息写入日志" class="headerlink" title="print_exc方法将错误信息写入日志"></a>print_exc方法将错误信息写入日志</h3><p>traceback模块有两种方法可以打印异常，一种是<code>format_exc</code>，另外一种是<code>print_exc</code><br>两者的去别在于：<code>print_exc</code>方法不仅可以在控制台打印错误信息，还能将错误信息写入到文件中。<br>将上面的代码改进一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"错误出现"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">    ERROR_LOG_PATH = os.path.join(BASE_DIR,<span class="string">'core'</span>,<span class="string">'error_log.log'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        error_func()</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">import</span> traceback</span><br><span class="line">        traceback.print_exc(file=open(ERROR_LOG_PATH,<span class="string">'a+'</span>))</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'继续执行'</span>)</span><br></pre></td></tr></table></figure><p>我们以追加的方式去向错误日志中写入异常，这样方便我们排查错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与异常做斗争已经是程序员的家常便饭了。很多时候我们需要将所有异常信息打印出来。比较通用的方法是直接利用异常去捕获：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;error_func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;string&quot;&gt;&quot;错误出现&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        error_func()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; ValueError &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;继续执行&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
      <category term="模块与包" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊sys的argv模块</title>
    <link href="http://yoursite.com/2019/05/01/%E8%81%8A%E4%B8%80%E8%81%8Asys%E7%9A%84argv%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/05/01/聊一聊sys的argv模块/</id>
    <published>2019-05-01T12:15:33.000Z</published>
    <updated>2019-09-21T04:28:21.226Z</updated>
    
    <content type="html"><![CDATA[<p>在以脚本的方式执行Python脚本的时候后面可以带多个参数，这些参数可以用<code>sys的argv模块</code>接收到。<br>新建一个<code>login.py</code>文件，文件中的内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure><p>在终端以Python脚本的方式运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 login.py <span class="number">123</span> <span class="number">456</span></span><br></pre></td></tr></table></figure><p>执行的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'/Users/wanghongwei/login.py'</span>,<span class="string">'123'</span>,<span class="string">'456'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a>我们可以看到：执行的结果是一个列表：列表的第一个元素是`当前执行的脚本的路径`，后面的元素是`执行脚本命令后面跟着的参数`，并且这些参数以空格隔开。<p>利用上面的结论我们可以做一个简单的<code>登陆脚本</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">"请输入正确的参数"</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"whw"</span> <span class="keyword">and</span> sys.argv[<span class="number">2</span>] == <span class="string">'123'</span>:</span><br><span class="line">        print(<span class="string">"登陆成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"登陆失败"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><p>在实际中，这样的登陆脚本要比下面用户输入的方式更高效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">username = input(<span class="string">'用户名：'</span>).strip()</span><br><span class="line">password = input(<span class="string">'密码：'</span>).strip()</span><br><span class="line"><span class="keyword">if</span> username == <span class="string">'whw'</span> <span class="keyword">and</span> password == <span class="string">'123'</span>:</span><br><span class="line">    print(<span class="string">'登陆成功！'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'登陆失败！'</span>)</span><br></pre></td></tr></table></figure><p>因为这种实现方式会让整个程序<code>阻塞</code>住，直到用户输入结束为止。<br>当然，实际中用哪一种模式还是要看具体的需求，本文只简单介绍一下sys的argv模块在调用Python脚本的时候接收参数的用法，而且这个用法在执行Python脚本的时候十分常见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以脚本的方式执行Python脚本的时候后面可以带多个参数，这些参数可以用&lt;code&gt;sys的argv模块&lt;/code&gt;接收到。&lt;br&gt;新建一个&lt;code&gt;login.py&lt;/code&gt;文件，文件中的内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(sys.argv)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在终端以Python脚本的方式运行：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python3 login.py &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行的结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;/Users/wanghongwei/login.py&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;123&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;456&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="模块与包" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>外部脚本调用Django环境</title>
    <link href="http://yoursite.com/2019/05/01/%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8Django%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/05/01/外部脚本调用Django环境/</id>
    <published>2019-05-01T02:32:12.000Z</published>
    <updated>2019-09-21T04:28:21.224Z</updated>
    
    <content type="html"><![CDATA[<p>如果在项目中我们使用的外部脚本需要调用Django模型层的类，此时必须要先在自己的脚本中为<code>os.environ</code>设置一个键值对，这个键值对要跟你的项目的根目录中<code>manage.py</code>文件里面的内容相同!<br>外部脚本的代码如下：<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"MultiTables.settings"</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="comment"># 注意引入要在上面三句之后</span></span><br><span class="line">    <span class="keyword">from</span> book <span class="keyword">import</span> models</span><br><span class="line">    ret = models.Book.objects.all()</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure><p>然后，我们看看目录结构：<br><img src="http://whw.pythonav.cn/%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83111.png" alt="img"><br>其实，Django项目在启动之初会加载用户自定义的配置文件，在<code>os.environ</code>这个字典中去设置一个key为<code>DJANGO_SETTINGS_MODULE</code>，value为<code>MultiTables.settings</code>（MultiTables是项目的名字）的键值对。<br>然后利用<code>importlib模块</code>与<code>反射</code>的方法找到用户配置文件中的配置再进行接下来的操作。<br>上面代码中的前三行表示<code>我们在外部脚本中调用了Django环境</code>，接下来就可以操作项目中的Model了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果在项目中我们使用的外部脚本需要调用Django模型层的类，此时必须要先在自己的脚本中为&lt;code&gt;os.environ&lt;/code&gt;设置一个键值对，这个键值对要跟你的项目的根目录中&lt;code&gt;manage.py&lt;/code&gt;文件里面的内容相同!&lt;br&gt;外部脚本的代码如下：
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django基础" scheme="http://yoursite.com/tags/Django%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Django原理" scheme="http://yoursite.com/tags/Django%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Django中执行原生SQL语句</title>
    <link href="http://yoursite.com/2019/05/01/Django%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/05/01/Django中执行原生SQL语句/</id>
    <published>2019-05-01T01:12:01.000Z</published>
    <updated>2019-09-21T04:28:21.220Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发中，在ORM模型查询API不够用的情况下，我们只能使用原始的SQL语句进行查询。<br>Django提供两种方法使用原生SQL进行查询：<br>一种是使用<code>raw()</code>方法，进行原始SQL查询并<code>返回模型实例</code>；另一种是<code>完全避开模型层，直接执行自定义的SQL语句</code>。</p><a id="more"></a><h3 id="raw-方法"><a href="#raw-方法" class="headerlink" title="raw()方法"></a>raw()方法</h3><p>raw()管理器方法用于原始的SQL查询，并返回<code>模型的实例</code>。<br>需要注意的是：<code>raw()语法查询必须包含主键</code>。<br>这个方法执行原始的SQL查询，并返回一个django.db.models.query.RawQuerySet 实例。 这个RawQuerySet 实例可以像一般的QuerySet那样，通过迭代来提供对象实例。</p><h4 id="利用raw方法执行原生的SQL语句"><a href="#利用raw方法执行原生的SQL语句" class="headerlink" title="利用raw方法执行原生的SQL语句"></a>利用raw方法执行原生的SQL语句</h4><p>假设现在我们有一个Book与Publish的Model：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = models.CharField(max_length=<span class="number">33</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line">    publisher = models.ForeignKey(to=<span class="string">'Publish'</span>,to_field=<span class="string">'id'</span>,on_delete=models.CASCADE)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">22</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>增加一条测试路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^raw/'</span>,views.raw),</span><br></pre></td></tr></table></figure><p>然后使用raw方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> book_obj <span class="keyword">in</span> Book.objects.raw(<span class="string">'select * from book_book where price&gt;100'</span>):</span><br><span class="line">    print(book_obj)</span><br></pre></td></tr></table></figure><p>结果为书籍对象（这里用的是我的测试数据，并且<strong>str</strong>方法返回书籍的title，因此打印的结果是书籍的title）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">ruby</span><br></pre></td></tr></table></figure><h4 id="raw-查询可以查询其他表的数据"><a href="#raw-查询可以查询其他表的数据" class="headerlink" title="raw()查询可以查询其他表的数据"></a>raw()查询可以查询其他表的数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意这里必须select id字段，否则会报错</span></span><br><span class="line">ret = Book.objects.raw(<span class="string">'select id,city from book_publish'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">    print(i.id,i.city)</span><br></pre></td></tr></table></figure><p>结果是Publish表的id与city：<code>注意必须要select id，否则会报错</code></p><h4 id="raw-方法自动将查询字段映射到模型字段"><a href="#raw-方法自动将查询字段映射到模型字段" class="headerlink" title="raw()方法自动将查询字段映射到模型字段"></a>raw()方法自动将查询字段映射到模型字段</h4><p>还可以通过translations参数指定一个把查询的字段名和ORM对象实例的字段名互相对应的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'city'</span>:<span class="string">'C'</span>&#125;</span><br><span class="line">    ret = Book.objects.raw(<span class="string">'select * from book_publish'</span>,translations=dic)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        print(i.id,i.name,i.C)</span><br></pre></td></tr></table></figure><p>结果为(这里用的是我自己的测试数据)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span> 苹果出版社 北京</span><br><span class="line"><span class="number">22</span> 橘子出版社 上海</span><br><span class="line"><span class="number">23</span> 樱桃出版社 成都</span><br><span class="line"><span class="number">24</span> 西瓜出版社 包头</span><br><span class="line"><span class="number">25</span> 橙子出版社 呼和浩特</span><br></pre></td></tr></table></figure><h4 id="原生SQL还可以使用参数，注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！"><a href="#原生SQL还可以使用参数，注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！" class="headerlink" title="原生SQL还可以使用参数，注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！"></a>原生SQL还可以使用参数，注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！</h4><p><strong>注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'city'</span>:<span class="string">'C'</span>&#125;</span><br><span class="line">ret = Book.objects.raw(<span class="string">'select * from book_publish where id &gt; %s'</span>,translations=dic,params=[<span class="number">22</span>,])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">    print(i.id,i.name,i.C)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span> 樱桃出版社 成都</span><br><span class="line"><span class="number">24</span> 西瓜出版社 包头</span><br><span class="line"><span class="number">25</span> 橙子出版社 呼和浩特</span><br></pre></td></tr></table></figure><h3 id="直接执行自定义的SQL语句"><a href="#直接执行自定义的SQL语句" class="headerlink" title="直接执行自定义的SQL语句"></a>直接执行自定义的SQL语句</h3><p><strong>有时候raw()方法并不十分好用，很多情况下我们不需要将查询结果映射成模型，或者我们需要执行DELETE、 INSERT以及UPDATE操作。</strong><br><strong>在这些情况下，我们可以直接访问数据库，完全避开模型层。</strong><br><strong>我们可以直接从django提供的接口中获取数据库连接，然后像使用pymysql模块一样操作数据库。</strong><br><strong>注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！</strong><br><strong>实现的方法如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection,connections</span><br><span class="line"></span><br><span class="line">cursor = connection.cursor()  <span class="comment">#cursor = connections['default'].cursor()</span></span><br><span class="line">cursor.execute(<span class="string">' select * from book_publish where id &gt; %s '</span>,[<span class="number">22</span>])</span><br><span class="line">ret = cursor.fetchall()</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发中，在ORM模型查询API不够用的情况下，我们只能使用原始的SQL语句进行查询。&lt;br&gt;Django提供两种方法使用原生SQL进行查询：&lt;br&gt;一种是使用&lt;code&gt;raw()&lt;/code&gt;方法，进行原始SQL查询并&lt;code&gt;返回模型实例&lt;/code&gt;；另一种是&lt;code&gt;完全避开模型层，直接执行自定义的SQL语句&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django基础" scheme="http://yoursite.com/tags/Django%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ORM" scheme="http://yoursite.com/tags/ORM/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于模块导入的单例模式</title>
    <link href="http://yoursite.com/2019/04/13/%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/13/基于模块导入的单例模式/</id>
    <published>2019-04-13T11:13:01.000Z</published>
    <updated>2019-09-21T04:28:21.224Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，如果已经导入过的文件再次被重新导入时候，python不会再重新解释一遍，而是选择从内存中直接将原来导入的值拿来用，这就是Python模块导入的特性。<br>依据这个特性，我们可以实现简单的<code>单例模式</code>。<br>让我们来新创建一个项目进行具体的说明。<a id="more"></a><br>项目的文件目录如下：<br><img src="http://whw.pythonav.cn/module_single_tone.png" alt="img"><br><code>singleton</code>中定义一个类并实例化一个对象，用来做单例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># singleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s = SingleTon()</span><br></pre></td></tr></table></figure><p><code>test1</code>与<code>test2</code>中分别导入这个类的对象并打印这个对象的内存地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="keyword">from</span> singleton <span class="keyword">import</span> s</span><br><span class="line"></span><br><span class="line">print(<span class="string">'test1:'</span>,s)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">from</span> singleton <span class="keyword">import</span> s</span><br><span class="line"></span><br><span class="line">print(<span class="string">'test2:'</span>,s)</span><br></pre></td></tr></table></figure><p><code>run</code>文件导入test1与test2，执行里面的print方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># run.py</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line"><span class="keyword">import</span> test2</span><br></pre></td></tr></table></figure><p>执行的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test1: &lt;singleton.SingleTon object at <span class="number">0x110204400</span>&gt;</span><br><span class="line">test2: &lt;singleton.SingleTon object at <span class="number">0x110204400</span>&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到：test1与test2中的<code>对象s</code>确实是一个<code>单例</code>！</p><h4 id="基于模块导入的单例模式进行传值"><a href="#基于模块导入的单例模式进行传值" class="headerlink" title="基于模块导入的单例模式进行传值"></a>基于模块导入的单例模式进行传值</h4><p>在上面的项目的基础上，既然<code>对象s</code>是一个<code>单例模式</code>，那么我们就可以利用它进行文件之前的传值了。<br>修改一下test1中的代码，在里面为s对象加一个name属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="keyword">from</span> singleton <span class="keyword">import</span> s</span><br><span class="line"></span><br><span class="line">s.name = <span class="string">"wanghw"</span></span><br></pre></td></tr></table></figure><p>然后在test2中，我们可以打印出s的那么属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">from</span> singleton <span class="keyword">import</span> s</span><br><span class="line"></span><br><span class="line">print(<span class="string">'name:'</span>,s.name)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: wanghw</span><br></pre></td></tr></table></figure><p>这样，我们就利用模块导入的原理实现了对象的传值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中，如果已经导入过的文件再次被重新导入时候，python不会再重新解释一遍，而是选择从内存中直接将原来导入的值拿来用，这就是Python模块导入的特性。&lt;br&gt;依据这个特性，我们可以实现简单的&lt;code&gt;单例模式&lt;/code&gt;。&lt;br&gt;让我们来新创建一个项目进行具体的说明。
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="模块与包" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊isinstance与type</title>
    <link href="http://yoursite.com/2019/04/07/%E8%81%8A%E4%B8%80%E8%81%8Aisinstance%E4%B8%8Etype/"/>
    <id>http://yoursite.com/2019/04/07/聊一聊isinstance与type/</id>
    <published>2019-04-07T15:15:01.000Z</published>
    <updated>2019-09-21T04:28:21.226Z</updated>
    
    <content type="html"><![CDATA[<p>最近写代码的时候遇到了一个关于<code>isinstance</code>与<code>type</code>的坑，这里给大家分享下，如果大家也遇到了同样的问题，希望本文能为大家解决疑惑。<a id="more"></a></p><h3 id="isinstance-obj-cls"><a href="#isinstance-obj-cls" class="headerlink" title="isinstance(obj,cls)"></a>isinstance(obj,cls)</h3><p>isinstance有两个参数，obj表示待比较的对象，cls表示“疑似是obj从属的类”，返回值是bool类型的True或者False<br>举一个简单的例子：我们想从一个多层嵌套的列表中获取每一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>,[<span class="number">9</span>,<span class="number">10</span>]]]]]</span><br></pre></td></tr></table></figure><p>这种问题我们可以用<code>递归</code>来解决这类问题：遍历这个列表，遇到数字类型的就直接打印，遇到列表类型的继续“递归”。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(lis)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">        <span class="keyword">if</span>  isinstance(i,int):</span><br><span class="line">           print(i,end=<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(i,list):</span><br><span class="line">            recursion(i)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    A = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>,[<span class="number">9</span>,<span class="number">10</span>]]]]]</span><br><span class="line">    recursion(A)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>关于本程序的改进大家可以忽略，写成酱紫的是为了帮助大家分析问题：我们在recursion函数中使用了isinstance去判断我们遍历的元素是列表类型还是int类型的，针对每一种类型我们做出不同的处理。</p><h4 id="isinstance“承认继承关系”"><a href="#isinstance“承认继承关系”" class="headerlink" title="isinstance“承认继承关系”"></a>isinstance“承认继承关系”</h4><p>何谓isinstance“承认继承关系”呢？上面的例子可能说明不了问题，我们在看下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span><span class="params">(object)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(GrandFather)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span><span class="keyword">pass</span></span><br><span class="line">son = Son()</span><br><span class="line">print(isinstance(son,Son))</span><br><span class="line">print(isinstance(son,Father))</span><br><span class="line">print(isinstance(son,GrandFather))</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，类Father继承自GrandFather，类Son继承自Father，对son是类Son实例化的一个对象。<br>结合小标题，大家猜一猜结果是什么呢？<br>结果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>也就是说，isinstance不止可以判断对象与实例化这个对象类的关系，还能接受“继承关系”。</p><h3 id="type-obj-cls"><a href="#type-obj-cls" class="headerlink" title="type(obj[cls])"></a>type(obj[cls])</h3><p>关于type就很有意思了：如果type里的参数是一个对象，那结果会显示实例化这个对象的类；那么如果里面的参数是一个类呢？<br>赶紧打开你的IDE试试！体会一下什么是Python中一切皆对象!<br>回到我们type里面是一个对象的话题：看下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="number">123</span>))</span><br><span class="line">print(type(<span class="string">'123'</span>))</span><br><span class="line">print(type([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">print(type((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line">print(type(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;))</span><br></pre></td></tr></table></figure><p>我们要查看这些数据对象的类型，当然我们一眼就可以看出来是什么类型的，so easy~结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">set</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>结果正如我们所料，但是，如果是一个我们自定义的类实例化出的对象呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">pass</span></span><br><span class="line">son = Son()</span><br><span class="line">print(type(son))</span><br></pre></td></tr></table></figure><p>如上所示，我们利用一个类Son实例化出一个对象son，那么结合上面的例子，type(son)的值是什么呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Son</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>结果就是当前文件的一个叫Son的东东，就是我们定义的Son类。</p><h4 id="type“不承认继承关系”"><a href="#type“不承认继承关系”" class="headerlink" title="type“不承认继承关系”"></a>type“不承认继承关系”</h4><p>说到这里，相信你会联想到上面isinstance的例子：要是继承会如何呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(GrandFather)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span><span class="keyword">pass</span></span><br><span class="line">son = Son()</span><br><span class="line">print(type(son) <span class="keyword">is</span> Son)</span><br><span class="line">print(type(son) <span class="keyword">is</span> Father )</span><br><span class="line">print(type(son) <span class="keyword">is</span> GrandFather )</span><br></pre></td></tr></table></figure><p>先给出结果再进行说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>我们可以看到，只有Son与type(son)相等，也就是说，只有直接实例化这个对象的类才是type(对象)的类，即使有继承关系，type也不会“承认”这个类的父类的<br>对于这个结论，大家记住就好了，希望本文内容能为大家以后的编码生涯避免一些BUG的产生！<br>最后，不知道你试过type(cls)没有，赶紧打开自己的IDE试试下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(GrandFather)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span><span class="keyword">pass</span></span><br><span class="line">son = Son()</span><br><span class="line"></span><br><span class="line">print(type(GrandFather))</span><br><span class="line">print(type(Father))</span><br><span class="line">print(type(Son))</span><br></pre></td></tr></table></figure><p>你会发现，结果是一样的！如果你对这个结果感兴趣，你可以查一下Python中的元类…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写代码的时候遇到了一个关于&lt;code&gt;isinstance&lt;/code&gt;与&lt;code&gt;type&lt;/code&gt;的坑，这里给大家分享下，如果大家也遇到了同样的问题，希望本文能为大家解决疑惑。
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>常见的缓存数据库及性能对比</title>
    <link href="http://yoursite.com/2019/04/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2019/04/06/常见的缓存数据库及性能对比/</id>
    <published>2019-04-06T01:13:23.000Z</published>
    <updated>2019-09-21T04:28:21.225Z</updated>
    
    <content type="html"><![CDATA[<p>在Python Web和Django开发过程中我们有必要根据不同的应用场景来选择非关系型的数据库(no-SQL)来提升网站性能。当我们的网站流量变得非常大时，从传统关系型数据库如MYSQL中读写数据会变得很消耗时间和计算资源。例如当MySQL单表数据达到5GB以上时，读写性能会有显著的下降，这时我们就需要考虑使用其它类型数据库来补充了。目前最流行的no-SQL数据库非MongoDB, Memcached和Redis莫属了。今天我们就来介绍下它们的区别及应用场景。<a id="more"></a></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a><code>MongoDB</code></h3><p>mongodb是文档型的非关系型no-SQL数据库，其优势在于查询功能比较强大，能存储海量数据。对于中小型网站而言，MySQL和其它关系型数据库完全能胜任，不需要使用MongoDB。对于大中型网站而言，MongoDB可以作为关系性数据库很好的补充。MongoDB由于侧重海量数据写入性能, 而非事务安全, 所以很适合存储业务系统中海量“低价值”的数据。对于事务要求很高的应用比如银行交易系统，MongoDB是不适用的。<br>MongoDB常见应用场景包括爬虫爬来数据的存储，存储网站的日志，存储海量用户的评论。<br>值得一提的是，mongodb数据和MySQL的数据都是保存在磁盘中的，而不是内存中，这是它与Memcached和Redis最大的区别。MongoDB本质上来看是用来永久存储数据的数据库，而Memcached和Redis主要用来做缓存，从这个角度讲Memcached和Redis更像。</p><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a><code>Memcached</code></h3><p>Memcached是内存性数据库，数据以Key-Value形式存储，主要用来提供高性能分布式内存缓存服务。在实际Web开发过程中，学会利用缓存是非常重要的。在动态网站中，用户每次请求一个页面，服务器都会执行以下操作：查询数据库，渲染模板，执行业务逻辑，最后生成用户可查看的页面。这会消耗大量的资源，当访问用户量非常大时，就要考虑这个问题了。缓存就是为了防止重复计算，把那些消耗了大量资源的结果保存起来，下次访问时就不用再次计算了，这样可以大大减轻数据库的负载。<br>由于memcached保存的数据都存储在memcached内置的内存存储空间中， 因此重启memcached、重启操作系统会导致全部数据消失。另外，内容容量达到指定值之后，就基于LRU(Least Recently Used)算法自动删除不使用的缓存。<br>Memcached的应用场景只有一个: 缓存。例如缓存一个页面，一个数据集或整个网站。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><code>Redis</code></h3><p>Redis也是一个开源的key-value存储系统。与Memcached类似，Redis将大部分数据存储在内存中，但支持数据类型更多，包括：字符串、哈希表、链表等。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。<br>Redis一般也用来提供高效的缓存服务，而不是做数据的永久存储。其应用场景有缓存和记录网站日志。<br>Redis和Memcached都可以设置缓存数据过期。在实际Web开发中，数据库缓存Redis和Memcached基本上是二选一。Redis作为后期之秀，越来越多抢了Memcached的风头。</p><h3 id="Django缓存系统选择之Memcached与Redis的区别与性能对比"><a href="#Django缓存系统选择之Memcached与Redis的区别与性能对比" class="headerlink" title="Django缓存系统选择之Memcached与Redis的区别与性能对比"></a>Django缓存系统选择之Memcached与Redis的区别与性能对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、过期策略--memcache在set时就指定，例如set key <span class="number">1008</span>,即永不过期。Redis可以通过例如expire 设定，例如expire name <span class="number">10</span>；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、Redis支持数据的备份，即master-slave模式的数据备份；</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、应用场景：redis（数据量较小的更性能操作和运算上）。memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）。</span><br></pre></td></tr></table></figure><h3 id="转载自下列文章"><a href="#转载自下列文章" class="headerlink" title="转载自下列文章"></a>转载自下列文章</h3><p><a href="https://blog.csdn.net/weixin_42134789/article/details/80568055" target="_blank" rel="noopener"><a href="https://blog.csdn.net/weixin_42134789/article/details/80568055" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42134789/article/details/80568055</a></a><br><a href="https://blog.csdn.net/weixin_42134789/article/details/80534343" target="_blank" rel="noopener"><a href="https://blog.csdn.net/weixin_42134789/article/details/80534343" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42134789/article/details/80534343</a></a></p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p><a href="https://www.oschina.net/news/26691/memcached-timeout" target="_blank" rel="noopener">&lt;Memcached 真的过时了吗？&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python Web和Django开发过程中我们有必要根据不同的应用场景来选择非关系型的数据库(no-SQL)来提升网站性能。当我们的网站流量变得非常大时，从传统关系型数据库如MYSQL中读写数据会变得很消耗时间和计算资源。例如当MySQL单表数据达到5GB以上时，读写性能会有显著的下降，这时我们就需要考虑使用其它类型数据库来补充了。目前最流行的no-SQL数据库非MongoDB, Memcached和Redis莫属了。今天我们就来介绍下它们的区别及应用场景。
    
    </summary>
    
    
      <category term="缓存" scheme="http://yoursite.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Python操作redis</title>
    <link href="http://yoursite.com/2019/04/05/Python%E6%93%8D%E4%BD%9Credis/"/>
    <id>http://yoursite.com/2019/04/05/Python操作redis/</id>
    <published>2019-04-05T14:13:55.000Z</published>
    <updated>2019-09-21T04:28:21.223Z</updated>
    
    <content type="html"><![CDATA[<p>首先记得安装redis模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># py3中</span></span><br><span class="line">sudo pip3 install redis</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="comment"># py2中</span></span><br><span class="line">sudo easy_install redis</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="comment"># 源码安装</span></span><br><span class="line">详见：https://github.com/WoLpH/redis-py</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a><code>API的使用</code></h3><p>redis-py 的API的使用可以分类为：</p><ul><li>连接方式</li><li>连接池</li><li>操作<ul><li>String 操作</li><li>Hash 操作</li><li>List 操作</li><li>Set 操作</li><li>Sort Set 操作</li></ul></li><li>管道</li><li>发布订阅</li></ul><h3 id="redis常见的面试题"><a href="#redis常见的面试题" class="headerlink" title="redis常见的面试题"></a><code>redis常见的面试题</code></h3><details>  <summary>redis常见的面试题</summary>  <pre><code>1. 使用Redis有哪些好处？(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)(2) 支持丰富数据类型，支持string，list，set，sorted set，hash(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除<ol start="2"><li><p>redis相比memcached有哪些优势？<br>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据</p></li><li><p>redis常见性能问题和解决方案：<br>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…<br>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p></li><li><p>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据<br>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：<br>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>no-enviction（驱逐）：禁止驱逐数据</p></li><li><p>Memcache与Redis的区别都有哪些？<br>1)、存储方式<br>Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。<br>Redis有部份存在硬盘上，这样能保证数据的持久性。<br>2)、数据支持类型<br>Memcache对数据类型支持相对简单。<br>Redis有复杂的数据类型。<br>3），value大小<br>redis最大可以达到1GB，而memcache只有1MB</p></li><li><p>Redis 常见的性能问题都有哪些？如何解决？<br>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p></li></ol><p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p><p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p><p>4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p><p>7, redis 最适合的场景</p><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?</p><p>***如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：<br>、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>、Redis支持数据的备份，即master-slave模式的数据备份。<br>、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p><p>（1）、会话缓存（Session Cache）<br>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？<br>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p>（2）、全页缓存（FPC）<br>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。<br>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。<br>此外，对WordPress的用户来说，Pantheon有一个非常好的插件  wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p>（3）、队列<br>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p>（4），排行榜/计数器<br>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：<br>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES</p><p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p>（5）、发布/订阅<br>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。<br>Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。<br>  </p></code></pre><p></p></details><h3 id="Python操作redis"><a href="#Python操作redis" class="headerlink" title="Python操作redis"></a><code>Python操作redis</code></h3><h4 id="1-操作模式"><a href="#1-操作模式" class="headerlink" title="1.操作模式"></a><code>1.操作模式</code></h4><p>redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">6379</span>,password=<span class="string">'123'</span>)</span><br><span class="line">r.set(<span class="string">'name1'</span>,<span class="string">'wanghw'</span>)</span><br><span class="line">print(r.get(<span class="string">'name1'</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6s后失效</span></span><br><span class="line">r.set(<span class="string">'name2'</span>,<span class="string">'www'</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="2-连接池"><a href="#2-连接池" class="headerlink" title="2.连接池"></a><code>2.连接池</code></h4><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</span><br><span class="line"><span class="keyword">print</span> r.get(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-Python对redis基本数据类型的操作"><a href="#3-Python对redis基本数据类型的操作" class="headerlink" title="3.Python对redis基本数据类型的操作"></a><code>3.Python对redis基本数据类型的操作</code></h4><h5 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a><code>String操作</code></h5><p><strong>redis中的String在在内存中按照一个name对应一个value来存储。如图：</strong><br><img src="http://whw.pythonav.cn/py%E6%93%8D%E4%BD%9Credis-string.png" alt="string"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String实现简单的k-v简直对存储，可以用作计数器等等。</span><br></pre></td></tr></table></figure><p><strong>1.set(name, value, ex=None, px=None, nx=False, xx=False)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Redis中设置值，默认，不存在则创建，存在则修改</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># ex，过期时间（秒）</span></span><br><span class="line">    <span class="comment"># px，过期时间（毫秒）</span></span><br><span class="line">    <span class="comment"># nx，如果设置为True，则只有name不存在时，当前set操作才执行</span></span><br><span class="line">    <span class="comment"># xx，如果设置为True，则只有name存在时，岗前set操作才执行</span></span><br></pre></td></tr></table></figure><p><strong>2.setnx(name, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置值，只有name不存在时，执行设置操作（添加）</span></span><br></pre></td></tr></table></figure><p><strong>3.setex(name, value, time)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># time，过期时间（数字秒 或 timedelta对象）</span></span><br></pre></td></tr></table></figure><p><strong>4.psetex(name, time_ms, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># time_ms，过期时间（数字毫秒 或 timedelta对象）</span></span><br></pre></td></tr></table></figure><p><strong>5.批量设置值</strong>——mset(<em>args, *</em>kwargs)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量设置值</span></span><br><span class="line">如：</span><br><span class="line">    <span class="comment"># mset(k1='v1', k2='v2')</span></span><br><span class="line">    或</span><br><span class="line">    <span class="comment"># mget(&#123;'k1': 'v1', 'k2': 'v2'&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>6.get(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取值</span></span><br></pre></td></tr></table></figure><p><strong>7.mget(keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量获取</span></span><br><span class="line">如：</span><br><span class="line">   <span class="comment"># mget('ylr', 'wupeiqi')</span></span><br><span class="line">    或</span><br><span class="line">   <span class="comment"># r.mget(['ylr', 'wupeiqi'])</span></span><br></pre></td></tr></table></figure><p><strong>8.getset(name, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置新值并获取原来的值</span></span><br></pre></td></tr></table></figure><p><strong>9.getrange(key, start, end)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取子序列（根据字节获取，非字符）</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，Redis 的 name</span></span><br><span class="line">    <span class="comment"># start，起始位置（字节）</span></span><br><span class="line">    <span class="comment"># end，结束位置（字节）</span></span><br><span class="line"><span class="comment"># 如： "孙悟空" ，0-3表示 "孙"</span></span><br></pre></td></tr></table></figure><p><strong>10.setrange(name, offset, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># offset，字符串的索引，字节（一个汉字三个字节）</span></span><br><span class="line">    <span class="comment"># value，要设置的值</span></span><br></pre></td></tr></table></figure><p><strong>11.setbit(name, offset, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对name对应值的二进制表示的位进行操作</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># offset，位的索引（将值变换成二进制后再进行索引）</span></span><br><span class="line">    <span class="comment"># value，值只能是 1 或 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 注：如果在Redis中有一个对应： n1 = "foo"，</span></span><br><span class="line">        那么字符串foo的二进制表示为：<span class="number">01100110</span> <span class="number">01101111</span> <span class="number">01101111</span></span><br><span class="line">    所以，如果执行 setbit(<span class="string">'n1'</span>, <span class="number">7</span>, <span class="number">1</span>)，则就会将第<span class="number">7</span>位设置为<span class="number">1</span>，</span><br><span class="line">        那么最终二进制则变成 <span class="number">01100111</span> <span class="number">01101111</span> <span class="number">01101111</span>，即：<span class="string">"goo"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 扩展，转换二进制表示：</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">    s = <span class="string">'王宏伟'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        num  = ord(i)</span><br><span class="line">        print(i)</span><br><span class="line">        print(num)</span><br><span class="line">        print(bin(num))</span><br><span class="line">        print(bin(num).replace(<span class="string">'b'</span>,<span class="string">''</span>))</span><br><span class="line"> </span><br><span class="line">    特别的，如果source是汉字 <span class="string">"王宏伟"</span>怎么办？</span><br><span class="line">    答：对于utf<span class="number">-8</span>，每一个汉字占 <span class="number">3</span> 个字节，那么 <span class="string">"王宏伟"</span> 则有 <span class="number">9</span>个字节</span><br><span class="line">       对于汉字，<span class="keyword">for</span>循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制</span><br><span class="line">        <span class="number">11100110</span> <span class="number">10101101</span> <span class="number">10100110</span> <span class="number">11100110</span> <span class="number">10110010</span> <span class="number">10011011</span> <span class="number">11101001</span> <span class="number">10111101</span> <span class="number">10010000</span></span><br><span class="line">        -------------------------- ----------------------------- -----------------------------</span><br><span class="line">                    王                         宏                           伟</span><br></pre></td></tr></table></figure><p><strong>12.getbit(name, offset)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的值的二进制表示中的某位的值 （0或1）</span></span><br></pre></td></tr></table></figure><p><strong>13.bitcount(key, start=None, end=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的值的二进制表示中 1 的个数</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># key，Redis的name</span></span><br><span class="line">    <span class="comment"># start，位起始位置</span></span><br><span class="line">    <span class="comment"># end，位结束位置</span></span><br></pre></td></tr></table></figure><p><strong>14.bitop(operation, dest, *keys)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）</span></span><br><span class="line">    <span class="comment"># dest, 新的Redis的name</span></span><br><span class="line">    <span class="comment"># *keys,要查找的Redis的name</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    bitop(<span class="string">"AND"</span>, <span class="string">'new_name'</span>, <span class="string">'n1'</span>, <span class="string">'n2'</span>, <span class="string">'n3'</span>)</span><br><span class="line">    <span class="comment"># 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中</span></span><br></pre></td></tr></table></figure><p><strong>15.strlen(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回name对应值的字节长度（一个汉字3个字节）</span></span><br></pre></td></tr></table></figure><p><strong>16.incr(self, name, amount=1)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name,Redis的name</span></span><br><span class="line">    <span class="comment"># amount,自增数（必须是整数）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 注：同incrby</span></span><br></pre></td></tr></table></figure><p><strong>17.incrbyfloat(self, name, amount=1.0)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name,Redis的name</span></span><br><span class="line">    <span class="comment"># amount,自增数（浮点型）</span></span><br></pre></td></tr></table></figure><p><strong>18.decr(self, name, amount=1)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name,Redis的name</span></span><br><span class="line">    <span class="comment"># amount,自减数（整数）</span></span><br></pre></td></tr></table></figure><p><strong>19.append(key, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在redis name对应的值后面追加内容</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    key, redis的name</span><br><span class="line">    value, 要追加的字符串</span><br></pre></td></tr></table></figure><h5 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a><code>Hash操作</code></h5><p>redis中Hash在内存中的存储格式如下图：<br><img src="http://whw.pythonav.cn/py%E6%93%8D%E4%BD%9Credis-Hash.png" alt="Hash"><br><strong>1.hset(name, key, value)</strong><br>——用来存储彼此相关信息的键值对。例如：<code>hset(name,id,username)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name对应的hash中设置一个键值对（不存在，则创建；否则，修改）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># key，name对应的hash中的key</span></span><br><span class="line">    <span class="comment"># value，name对应的hash中的value</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 注：</span></span><br><span class="line">    <span class="comment"># hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）</span></span><br></pre></td></tr></table></figure><p><strong>2.hmset(name, mapping)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的hash中批量设置键值对</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># mapping，字典，如：&#123;'k1':'v1', 'k2': 'v2'&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    <span class="comment"># r.hmset('xx', &#123;'k1':'v1', 'k2': 'v2'&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>3.hget(name,key)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的hash中获取根据key获取value</span></span><br></pre></td></tr></table></figure><p><strong>4.hmget(name, keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的hash中获取多个key的值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，reids对应的name</span></span><br><span class="line">    <span class="comment"># keys，要获取key集合，如：['k1', 'k2', 'k3']</span></span><br><span class="line">    <span class="comment"># *args，要获取的key，如：k1,k2,k3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    <span class="comment"># r.mget('xx', ['k1', 'k2'])</span></span><br><span class="line">    <span class="comment"># 或</span></span><br><span class="line">    <span class="comment"># print r.hmget('xx', 'k1', 'k2')</span></span><br></pre></td></tr></table></figure><p><strong>5.hgetall(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应hash的所有键值</span></span><br></pre></td></tr></table></figure><p><strong>6.hlen(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的hash中键值对的个数</span></span><br></pre></td></tr></table></figure><p><strong>7.hkeys(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的hash中所有的key的值</span></span><br></pre></td></tr></table></figure><p><strong>8.hvals(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的hash中所有的value的值</span></span><br></pre></td></tr></table></figure><p><strong>9.hexists(name, key)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查name对应的hash是否存在当前传入的key</span></span><br></pre></td></tr></table></figure><p><strong>10.hdel(name,*keys)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将name对应的hash中指定key的键值对删除</span></span><br></pre></td></tr></table></figure><p><strong>11.hincrby(name, key, amount=1)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自增name对应的hash中的指定key的值，不存在则创建key=amount</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis中的name</span></span><br><span class="line">    <span class="comment"># key， hash对应的key</span></span><br><span class="line">    <span class="comment"># amount，自增数（整数）</span></span><br></pre></td></tr></table></figure><p><strong>12.hincrbyfloat(name, key, amount=1.0)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自增name对应的hash中的指定key的值，不存在则创建key=amount</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis中的name</span></span><br><span class="line">    <span class="comment"># key， hash对应的key</span></span><br><span class="line">    <span class="comment"># amount，自增数（浮点数）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 自增name对应的hash中的指定key的值，不存在则创建key=amount</span></span><br></pre></td></tr></table></figure><p><strong>13.hscan(name, cursor=0, match=None, count=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># cursor，游标（基于游标分批取获取数据）</span></span><br><span class="line">    <span class="comment"># match，匹配指定key，默认None 表示所有的key</span></span><br><span class="line">    <span class="comment"># count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    <span class="comment"># 第一次：cursor1, data1 = r.hscan('xx', cursor=0, match=None, count=None)</span></span><br><span class="line">    <span class="comment"># 第二次：cursor2, data1 = r.hscan('xx', cursor=cursor1, match=None, count=None)</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕</span></span><br></pre></td></tr></table></figure><p><strong>14.hscan_iter(name, match=None, count=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用yield封装hscan创建生成器，实现分批去redis中获取数据</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># match，匹配指定key，默认None 表示所有的key</span></span><br><span class="line">    <span class="comment"># count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    <span class="comment"># for item in r.hscan_iter('xx'):</span></span><br><span class="line">    <span class="comment">#     print item</span></span><br></pre></td></tr></table></figure><h5 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a><code>List操作</code></h5><p>List即链表，可以实现<code>双向链表</code>，比如用户的关注、粉丝列表等等。<br>redis中的List在在内存中按照一个name对应一个List来存储。如图：<br><img src="http://whw.pythonav.cn/py%E6%93%8D%E4%BD%9Credis-list.png" alt="List"><br><strong>1.lpush(name,values)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的list中添加元素，每个新的元素都添加到列表的最左边</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    <span class="comment"># r.lpush('oo', 11,22,33)</span></span><br><span class="line">    <span class="comment"># 保存顺序为: 33,22,11</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 扩展：</span></span><br><span class="line">    <span class="comment"># rpush(name, values) 表示从右向左操作</span></span><br></pre></td></tr></table></figure><p><strong>2.lpushx(name,value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># rpushx(name, value) 表示从右向左操作</span></span><br></pre></td></tr></table></figure><p><strong>3.llen(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name对应的list元素的个数</span></span><br></pre></td></tr></table></figure><p><strong>4.linsert(name, where, refvalue, value))</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的列表的某一个值前或后插入一个新值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># where，BEFORE或AFTER</span></span><br><span class="line">    <span class="comment"># refvalue，标杆值，即：在它前后插入数据</span></span><br><span class="line">    <span class="comment"># value，要插入的数据</span></span><br></pre></td></tr></table></figure><p><strong>5.lset(name, index, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对name对应的list中的某一个索引位置重新赋值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># index，list的索引位置</span></span><br><span class="line">    <span class="comment"># value，要设置的值</span></span><br></pre></td></tr></table></figure><p><strong>6.lrem(name, value, num)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的list中删除指定的值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># value，要删除的值</span></span><br><span class="line">    <span class="comment"># num，num=0，删除列表中所有的指定值；</span></span><br><span class="line">           <span class="comment"># num=2,从前到后，删除2个；</span></span><br><span class="line">           <span class="comment"># num=-2,从后向前，删除2个</span></span><br></pre></td></tr></table></figure><p><strong>7.lpop(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># rpop(name) 表示从右向左操作</span></span><br></pre></td></tr></table></figure><p><strong>8.lindex(name, index)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的列表中根据索引获取列表元素</span></span><br></pre></td></tr></table></figure><p><strong>9.lrange(name, start, end)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的列表分片获取数据</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># start，索引的起始位置</span></span><br><span class="line">    <span class="comment"># end，索引结束位置</span></span><br></pre></td></tr></table></figure><p><strong>10.ltrim(name, start, end)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的列表中移除没有在start-end索引之间的值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># start，索引的起始位置</span></span><br><span class="line">    <span class="comment"># end，索引结束位置</span></span><br></pre></td></tr></table></figure><p><strong>11.rpoplpush(src, dst)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># src，要取数据的列表的name</span></span><br><span class="line">    <span class="comment"># dst，要添加数据的列表的name</span></span><br></pre></td></tr></table></figure><p><strong>12.blpop(keys, timeout)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多个列表排列，按照从左到右去pop对应列表的元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># keys，redis的name的集合</span></span><br><span class="line">    <span class="comment"># timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># r.brpop(keys, timeout)，从右向左获取数据</span></span><br></pre></td></tr></table></figure><p><strong>13.brpoplpush(src, dst, timeout=0)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># src，取出并要移除元素的列表对应的name</span></span><br><span class="line">    <span class="comment"># dst，要插入元素的列表对应的name</span></span><br><span class="line">    <span class="comment"># timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞</span></span><br></pre></td></tr></table></figure><p><strong>14.自定义增量迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：</span></span><br><span class="line">    <span class="comment"># 1、获取name对应的所有列表</span></span><br><span class="line">    <span class="comment"># 2、循环列表</span></span><br><span class="line"><span class="comment"># 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_iter</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    自定义redis列表增量迭代</span></span><br><span class="line"><span class="string">    :param name: redis中的name，即：迭代name对应的列表</span></span><br><span class="line"><span class="string">    :return: yield 返回 列表元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    list_count = r.llen(name)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(list_count):</span><br><span class="line">        <span class="keyword">yield</span> r.lindex(name, index)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_iter(<span class="string">'pp'</span>):</span><br><span class="line">    <span class="keyword">print</span> item</span><br></pre></td></tr></table></figure><h5 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a><code>Set操作</code></h5><p>Set集合就是不允许重复的列表。<code>它用来存储不重复的元素，比如用户的关注者等等</code>。<br><strong>1.sadd(name,values)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name对应的集合中添加元素</span></span><br></pre></td></tr></table></figure><p><strong>2.scard(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的集合中元素个数</span></span><br></pre></td></tr></table></figure><p><strong>3.sdiff(keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第一个name对应的集合中且不在其他name对应的集合的元素集合</span></span><br></pre></td></tr></table></figure><p><strong>4.sdiffstore(dest, keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中</span></span><br></pre></td></tr></table></figure><p><strong>5.sinter(keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取多一个name对应集合的并集</span></span><br></pre></td></tr></table></figure><p><strong>6.sinterstore(dest, keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取多一个name对应集合的并集，再讲其加入到dest对应的集合中</span></span><br></pre></td></tr></table></figure><p><strong>7.sismember(name, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查value是否是name对应的集合的成员</span></span><br></pre></td></tr></table></figure><p><strong>8.smembers(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的集合的所有成员</span></span><br></pre></td></tr></table></figure><p><strong>9.smove(src, dst, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将某个成员从一个集合中移动到另外一个集合</span></span><br></pre></td></tr></table></figure><p><strong>10.spop(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从集合的右侧（尾部）移除一个成员，并将其返回</span></span><br></pre></td></tr></table></figure><p><strong>11.srandmember(name, numbers)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从name对应的集合中随机获取 numbers 个元素</span></span><br></pre></td></tr></table></figure><p><strong>12.srem(name, values)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的集合中删除某些值</span></span><br></pre></td></tr></table></figure><p><strong>13.sunion(keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取多一个name对应的集合的并集</span></span><br></pre></td></tr></table></figure><p><strong>14.sunionstore(dest,keys, *args)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中</span></span><br></pre></td></tr></table></figure><p><strong>15.</strong><br><strong>sscan(name, cursor=0, match=None, count=None)</strong><br><strong>sscan_iter(name, match=None, count=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大</span></span><br></pre></td></tr></table></figure><h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a><code>有序集合</code></h5><p>在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。<code>可以实现实时信息排行榜等。</code><br><strong>1.在name对应的有序集合中添加元素：</strong>zadd(name, <em>args, *</em>kwargs)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在name对应的有序集合中添加元素</span></span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">     <span class="comment"># zadd('zz', 'n1', 1, 'n2', 2)</span></span><br><span class="line">     <span class="comment"># 或</span></span><br><span class="line">     <span class="comment"># zadd('zz', n1=11, n2=22)</span></span><br></pre></td></tr></table></figure><p><strong>2.zcard(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的有序集合元素的数量</span></span><br></pre></td></tr></table></figure><p><strong>3.zcount(name, min, max)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应的有序集合中分数 在 [min,max] 之间的个数</span></span><br></pre></td></tr></table></figure><p><strong>4.zincrby(name, value, amount)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自增name对应的有序集合的 name 对应的分数</span></span><br></pre></td></tr></table></figure><p><strong>5.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照索引范围获取name对应的有序集合的元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># start，有序集合索引起始位置（非分数）</span></span><br><span class="line">    <span class="comment"># end，有序集合索引结束位置（非分数）</span></span><br><span class="line">    <span class="comment"># desc，排序规则，默认按照分数从小到大排序</span></span><br><span class="line">    <span class="comment"># withscores，是否获取元素的分数，默认只获取元素的值</span></span><br><span class="line">    <span class="comment"># score_cast_func，对分数进行数据转换的函数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># 从大到小排序</span></span><br><span class="line">    <span class="comment"># zrevrange(name, start, end, withscores=False, score_cast_func=float)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 按照分数范围获取name对应的有序集合的元素</span></span><br><span class="line">    <span class="comment"># zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</span></span><br><span class="line">    <span class="comment"># 从大到小排序</span></span><br><span class="line">    <span class="comment"># zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)</span></span><br></pre></td></tr></table></figure><p><strong>6.zrank(name, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取某个值在 name对应的有序集合中的排行（从 0 开始）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># zrevrank(name, value)，从大到小排序</span></span><br></pre></td></tr></table></figure><p><strong>7.zrangebylex(name, min, max, start=None, num=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员</span></span><br><span class="line"><span class="comment"># 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间</span></span><br><span class="line">    <span class="comment"># min，右区间（值）</span></span><br><span class="line">    <span class="comment"># start，对结果进行分片处理，索引位置</span></span><br><span class="line">    <span class="comment"># num，对结果进行分片处理，索引后面的num个元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">    <span class="comment"># ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga</span></span><br><span class="line">    <span class="comment"># r.zrangebylex('myzset', "-", "[ca") 结果为：['aa', 'ba', 'ca']</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># 从大到小排序</span></span><br><span class="line">    <span class="comment"># zrevrangebylex(name, max, min, start=None, num=None)</span></span><br></pre></td></tr></table></figure><p><strong>8.zrem(name, values)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除name对应的有序集合中值是values的成员</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如：zrem('zz', ['s1', 's2'])</span></span><br></pre></td></tr></table></figure><p><strong>9.zremrangebyrank(name, min, max)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据排行范围删除</span></span><br></pre></td></tr></table></figure><p><strong>10.zremrangebyscore(name, min, max)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据分数范围删除</span></span><br></pre></td></tr></table></figure><p><strong>11.zremrangebylex(name, min, max)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据值返回删除</span></span><br></pre></td></tr></table></figure><p><strong>12.zscore(name, value)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应有序集合中 value 对应的分数</span></span><br></pre></td></tr></table></figure><p><strong>13.zinterstore(dest, keys, aggregate=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作</span></span><br><span class="line"><span class="comment"># aggregate的值为:  SUM  MIN  MAX</span></span><br></pre></td></tr></table></figure><p><strong>14.zunionstore(dest, keys, aggregate=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作</span></span><br><span class="line"><span class="comment"># aggregate的值为:  SUM  MIN  MAX</span></span><br></pre></td></tr></table></figure><p><strong>15.</strong><br><strong>zscan(name, cursor=0, match=None, count=None, score_cast_func=float)</strong><br><strong>zscan_iter(name, match=None, count=None,score_cast_func=float)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作</span></span><br></pre></td></tr></table></figure><h5 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a><code>其他常用操作</code></h5><p><strong>1.delete(*names)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据删除redis中的任意数据类型</span></span><br></pre></td></tr></table></figure><p><strong>2.exists(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测redis的name是否存在</span></span><br></pre></td></tr></table></figure><p><strong>3.keys(pattern=’*’)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据模型获取redis的name</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># KEYS * 匹配数据库中所有 key 。</span></span><br><span class="line">    <span class="comment"># KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span></span><br><span class="line">    <span class="comment"># KEYS h*llo 匹配 hllo 和 heeeeello 等。</span></span><br><span class="line">    <span class="comment"># KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</span></span><br></pre></td></tr></table></figure><p><strong>4.expire(name ,time)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为某个redis的某个name设置超时时间</span></span><br></pre></td></tr></table></figure><p><strong>5.rename(src, dst)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对redis的name重命名为</span></span><br></pre></td></tr></table></figure><p><strong>6.move(name, db))</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将redis的某个值移动到指定的db下</span></span><br></pre></td></tr></table></figure><p><strong>7.randomkey()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机获取一个redis的name（不删除）</span></span><br></pre></td></tr></table></figure><p><strong>8.type(name)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取name对应值的类型</span></span><br></pre></td></tr></table></figure><p><strong>9.</strong><br><strong>scan(cursor=0, match=None, count=None)</strong><br><strong>scan_iter(match=None, count=None)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同字符串操作，用于增量迭代获取key</span></span><br></pre></td></tr></table></figure><h3 id="redis中的事物——管道与计数器的实现"><a href="#redis中的事物——管道与计数器的实现" class="headerlink" title="redis中的事物——管道与计数器的实现"></a><code>redis中的事物——管道与计数器的实现</code></h3><p><strong>1.管道</strong><br>redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline是原子性操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># pipe = r.pipeline(transaction=False)</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 开始事物</span></span><br><span class="line">pipe.multi()</span><br><span class="line">pipe.set(<span class="string">'name'</span>, <span class="string">'alex'</span>)</span><br><span class="line">pipe.set(<span class="string">'role'</span>, <span class="string">'sb'</span>)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure><p><strong>2.计数器的实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">conn = redis.Redis(host=<span class="string">'192.168.1.41'</span>,port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">conn.set(<span class="string">'count'</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> conn.pipeline() <span class="keyword">as</span> pipe:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先监视，自己的值没有被修改过</span></span><br><span class="line">    conn.watch(<span class="string">'count'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 事务开始</span></span><br><span class="line">    pipe.multi()</span><br><span class="line">    old_count = conn.get(<span class="string">'count'</span>)</span><br><span class="line">    count = int(old_count)</span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">0</span>:  <span class="comment"># 有库存</span></span><br><span class="line">        pipe.set(<span class="string">'count'</span>, count - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行，把所有命令一次性推送过去</span></span><br><span class="line">    pipe.execute()</span><br></pre></td></tr></table></figure><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a><code>发布订阅</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布者：服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者：Dashboad和数据处理</span></span><br></pre></td></tr></table></figure><p><img src="http://whw.pythonav.cn/py%E6%93%8D%E4%BD%9Credis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png" alt="发布订阅"></p><h4 id="一个简单的Demo"><a href="#一个简单的Demo" class="headerlink" title="一个简单的Demo"></a><code>一个简单的Demo</code></h4><p><strong>RedisHelper：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">'10.211.55.4'</span>)</span><br><span class="line">        self.chan_sub = <span class="string">'fm104.5'</span></span><br><span class="line">        self.chan_pub = <span class="string">'fm104.5'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.__conn.publish(self.chan_pub, msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self)</span>:</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        pub.subscribe(self.chan_sub)</span><br><span class="line">        pub.parse_response()</span><br><span class="line">        <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure><p><strong>订阅者：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> monitor.RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"> </span><br><span class="line">obj = RedisHelper()</span><br><span class="line">redis_sub = obj.subscribe()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg= redis_sub.parse_response()</span><br><span class="line">    <span class="keyword">print</span> msg</span><br></pre></td></tr></table></figure><p><strong>发布者：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> monitor.RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"> </span><br><span class="line">obj = RedisHelper()</span><br><span class="line">obj.public(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><h3 id="redis哨兵sentinel"><a href="#redis哨兵sentinel" class="headerlink" title="redis哨兵sentinel"></a><code>redis哨兵sentinel</code></h3><p>redis重的sentinel主要用于在redis主从复制中，如果master顾上，则自动将slave替换成master</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接哨兵服务器(主机名也可以用域名)</span></span><br><span class="line">sentinel = Sentinel([(<span class="string">'10.211.55.20'</span>, <span class="number">26379</span>),</span><br><span class="line">                     (<span class="string">'10.211.55.20'</span>, <span class="number">26380</span>),</span><br><span class="line">                     ],</span><br><span class="line">                    socket_timeout=<span class="number">0.5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 获取主服务器地址</span></span><br><span class="line"> master = sentinel.discover_master(<span class="string">'mymaster'</span>)</span><br><span class="line"> print(master)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># # 获取从服务器地址</span></span><br><span class="line"> slave = sentinel.discover_slaves(<span class="string">'mymaster'</span>)</span><br><span class="line"> print(slave)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># # 获取主服务器进行写入</span></span><br><span class="line"> master = sentinel.master_for(<span class="string">'mymaster'</span>)</span><br><span class="line"> master.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># # # 获取从服务器进行读取（默认是round-roubin）</span></span><br><span class="line"> slave = sentinel.slave_for(<span class="string">'mymaster'</span>, password=<span class="string">'redis_auth_pass'</span>)</span><br><span class="line"> r_ret = slave.get(<span class="string">'foo'</span>)</span><br><span class="line"> print(r_ret)</span><br></pre></td></tr></table></figure><h3 id="转载自下面的文章"><a href="#转载自下面的文章" class="headerlink" title="转载自下面的文章"></a><code>转载自下面的文章</code></h3><p><a href="https://www.cnblogs.com/wupeiqi/articles/5132791.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/wupeiqi/articles/5132791.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/articles/5132791.html</a></a></p><h3 id="更多redis资料"><a href="#更多redis资料" class="headerlink" title="更多redis资料"></a><code>更多redis资料</code></h3><p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a><br><a href="https://github.com/andymccurdy/redis-py/" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先记得安装redis模块&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# py3中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo pip3 install redis&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# py2中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo easy_install redis&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 源码安装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;详见：https://github.com/WoLpH/redis-py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Django中使用redis做缓存的配置方法</title>
    <link href="http://yoursite.com/2019/04/05/Django%E4%B8%AD%E4%BD%BF%E7%94%A8redis%E5%81%9A%E7%BC%93%E5%AD%98%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/05/Django中使用redis做缓存的配置方法/</id>
    <published>2019-04-05T11:23:21.000Z</published>
    <updated>2019-09-21T04:28:21.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍一下在Django中使用redis做缓存的配置方法、具体实例以及结果查看。<a id="more"></a></p><h3 id="settings中全局的配置"><a href="#settings中全局的配置" class="headerlink" title="settings中全局的配置"></a>settings中全局的配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis缓存设置</span></span><br><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django_redis.cache.RedisCache'</span>,</span><br><span class="line">        <span class="string">'LOCATION'</span>: <span class="string">'redis://127.0.0.1:6379'</span>,</span><br><span class="line">        <span class="string">"OPTIONS"</span>: &#123;</span><br><span class="line">            <span class="string">"CLIENT_CLASS"</span>: <span class="string">"django_redis.client.DefaultClient"</span>,</span><br><span class="line">             <span class="comment"># 如果没设置密码将这行注释掉</span></span><br><span class="line">             <span class="string">"PASSWORD"</span>: <span class="string">"123"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局的设置优先于cache_page装饰器中的配置</span></span><br><span class="line">REDIS_TIMEOUT=<span class="number">7</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span></span><br><span class="line">CUBES_REDIS_TIMEOUT=<span class="number">60</span>*<span class="number">60</span></span><br><span class="line">NEVER_REDIS_TIMEOUT=<span class="number">365</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span></span><br></pre></td></tr></table></figure><h3 id="站点缓存的方法"><a href="#站点缓存的方法" class="headerlink" title="站点缓存的方法"></a>站点缓存的方法</h3><p>站点缓存需要在settings中注册两个中间件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="comment"># 站点缓存中间件UpdateCacheMiddleware，注意必须在第一个位置</span></span><br><span class="line">    <span class="string">'django.middleware.cache.UpdateCacheMiddleware'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他中间件</span></span><br><span class="line">     xxx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 站点缓存中间件FetchFromCacheMiddleware,注意必须在最后一个位置</span></span><br><span class="line">    <span class="string">'django.middleware.cache.FetchFromCacheMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>路由与视图按照正常写法即可。</p><h3 id="视图中缓存的方法"><a href="#视图中缓存的方法" class="headerlink" title="视图中缓存的方法"></a>视图中缓存的方法</h3><h4 id="FBV视图中加装饰器"><a href="#FBV视图中加装饰器" class="headerlink" title="FBV视图中加装饰器"></a>FBV视图中加装饰器</h4><h5 id="URL的写法"><a href="#URL的写法" class="headerlink" title="URL的写法"></a>URL的写法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br></pre></td></tr></table></figure><h5 id="视图中加装饰器"><a href="#视图中加装饰器" class="headerlink" title="视图中加装饰器"></a>视图中加装饰器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置timeout为10秒，优先级低于settings中的配置</span></span><br><span class="line"><span class="meta">@cache_page(10)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    ret = models.Question.objects.filter(pub_date__lte=timezone.now()).order_by(<span class="string">"-pub_date"</span>)[:<span class="number">15</span>]</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'polls/index.html'</span>,&#123;<span class="string">'latest_question_list'</span>:ret&#125;)</span><br></pre></td></tr></table></figure><h4 id="CBV视图中加装饰器"><a href="#CBV视图中加装饰器" class="headerlink" title="CBV视图中加装饰器"></a>CBV视图中加装饰器</h4><h5 id="URL的写法-1"><a href="#URL的写法-1" class="headerlink" title="URL的写法"></a>URL的写法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">''</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br></pre></td></tr></table></figure><h5 id="视图中加装饰器-1"><a href="#视图中加装饰器-1" class="headerlink" title="视图中加装饰器"></a>视图中加装饰器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(cache_page(10),name='get')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexView</span><span class="params">(View)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 也可以在get方法中加，注意需要设置timeout的值</span></span><br><span class="line">    <span class="comment"># @method_decorator(cache_page(10))</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        ret = models.Question.objects.filter(pub_date__lte=timezone.now()).order_by(<span class="string">"-pub_date"</span>)[:<span class="number">15</span>]</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, &#123;<span class="string">'latest_question_list'</span>: ret&#125;)</span><br></pre></td></tr></table></figure><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><h4 id="redis客户端查看新增的keys"><a href="#redis客户端查看新增的keys" class="headerlink" title="redis客户端查看新增的keys"></a>redis客户端查看新增的keys</h4><p><img src="http://whw.pythonav.cn/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98666.png" alt="333"></p><h4 id="redis桌面工具查看结果"><a href="#redis桌面工具查看结果" class="headerlink" title="redis桌面工具查看结果"></a>redis桌面工具查看结果</h4><p>设置完后，我们根据项目的路由设置在页面中发一个get请求，可以看到redis中有了这个缓存信息：<br><img src="http://whw.pythonav.cn/redis%E7%BC%93%E5%AD%98666.png" alt="222"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍一下在Django中使用redis做缓存的配置方法、具体实例以及结果查看。
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
